


#

Notes:


  .
    The listings are from dotnet/runtime around 72ad6649b505a98cae5ff296818df2d7a5da4807
    (i.e., around 10-Nov-2022).


  .
    The motivating command line was the

        build.cmd -arch x64 -os windows -s clr -c Release

    command that LakshanF was using to drive successful builds of the CoreCLR product.


  .
    The initial work associated with building these notes was accounted as #T920.





#

Build tool notes:



    #

    CMake:

      [[
        $ where /r "c:\Program Files (x86)" cmake.exe
        c:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe

        $ where /r "c:\Program Files" cmake.exe
        c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe

        $ call c:\bin\Fragile\BinQuery.exe ShowKind "c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe"
        [Native(amd64(0x8664))]                                 Path=c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin\cmake.exe
      ]]



    #

    Ninja:

      [[
        $ where /r "c:\Program Files (x86)" ninja.exe
        c:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe

        $ where /r "c:\Program Files" ninja.exe
        c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe

        $ call c:\bin\Fragile\BinQuery.exe ShowKind "c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe"
        [Native(amd64(0x8664))]                                 Path=c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe
      ]]




#

Notes:


"c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" -host_arch=amd64 -arch=x86
"c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" -host_arch=amd64 -arch=amd64




    #

    The text at

        https://github.com/dotnet/runtime/blob/main/docs/workflow/requirements/windows-requirements.md

    nicely describes the somewhat extensive set of steps needed to configure a Windows
    machine to build the dotnet/runtime repo.

    Notes:



        #

        Native tools are bound at the following point

            {l:\Git\github\dotnet\runtime\eng\native\init-vs-env.cmd}
            {l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}
            ...

        and this is where init-vs-env.cmd enforces the VS2022 requirement.

        Note that the discussion at the top of the build-runtime.cmd listing describes the
        (long) series of steps that connect the top-level build.cmd through to the
        build-runtime.cmd shown in the stack trace above.



        #

        For long paths, after setting LongPathsEnabled to 0x1 and rebooting (on xk5):

          [[
            $ reg query HKLM\SYSTEM\CurrentControlSet\Control\FileSystem /v LongPathsEnabled

            HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem
                LongPathsEnabled    REG_DWORD    0x1

            $ git config --system core.longpaths true
          ]]



        #

        For CMake, the Visual Studio Installer indicated that it was already an installed part
        of the VS2022 installation.



        #

        For Python,

          .
            opening Visual Studio Installer,

          .
            selecting "Modify" on the VS2022 installation,

          .
            and then installing Python from the "Individual Components" list

        established a runnable "py" command at:

            C:\Windows\py.exe



        #

        For Ninja:

          [[
            $ where /r "c:\Program Files (x86)" ninja.exe
            c:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe

            $ where /r "c:\Program Files" ninja.exe
            c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe
          ]]



#

Notes related to seeing full command lines:



    #

    Some background on Ninja:

        The current dotnet/runtime build system uses the Ninja generator across all platforms.

        In this context, "using the Ninja generator" refers to configuring CMake to emit the
        physical build system as a build.ninja file, which contains a build description which
        allows a Ninja build command (e.g., "ninja install") to synchronously invoke all of the
        required command lines.

        Ninja apparently has a strong focus on performance (e.g., via parallelization), and has
        gained a lot of popularity on those grounds (i.e., on the grounds that the build runs
        more efficiently and completes faster when it is driven via a build.ninja build
        description as opposed to an MSBuild description or whatever else).

        The content in

            m:\Z\NascentNotes\NetCore\BuildSystem\2022\Ref\001_ReferenceOnNinjaTraitsAndBuildIntegration.txt

        contains the most concrete and comprehensive discussion of how Ninja plugs into the
        dotnet/runtime build, and what options exist for preventing it from "hiding" whatever
        command line arguments are passed via *.rsp files.


    After initial research and experimentation, the Teams message fragment below captures my
    initial stance on the "best" way to collect full command lines for arbitrary build
    commands:

      [[
        Here is the mechanism I've identified for collecting full link.exe command lines:

        After a CoreCLR build has completed successfully, all experiments so far suggest that we
        can get full command lines for everything by running the following extra step in the
        same window that ran the successful build:

            cd /d C:\Git\github\dotnet\runtime\artifacts\obj\coreclr\windows.x64.Debug
            ninja -t compdb -x > all_commands.json

        (Where you'll need to change "C:\Git\github\dotnet" to the actual path of your
        dotnet/runtime enlistment, and you might need to type the full path of ninja.exe if you
        are not in a VS developer command prompt.)

        The all_commands.json is similar to the compile_commands.json we've been using, but it
        includes (at least) lib.exe and link.exe commands as well.  Also, the "-x" part of the
        command means that all command lines are complete, even if they are super-long and are
        physically executed by "hiding" many of the arguments in a *.rsp file.

        Overall, after running the command above to put all_commands.json into the
        windows.x64.Debug area, the windows.x64.Debug directory tree should contain everything
        we'd need to dig into how any *.lib or *.dll is put together in the working CoreCLR case
        (i.e., it shows the linker commands and contains copies of the *.obj and *.lib files
        that were being linked together).

        (There are other options for getting full command lines, but the one above seems to be
        the most straightforward.  For example, doing "set VERBOSE=1" in the cmd window
        immediately before kicking off build.cmd causes CMake to pass a -v switch to Ninja
        ("ninja -v install"), which makes Ninja print each command line to the console.  The
        problem is that many of these (including the link.exe command line for coreclr.dll) hide
        most arguments in a *.rsp file which Ninja immediately deletes.  So the command line
        printed to the console just points to a *.rsp file that no longer exists.  Adding "-d
        keeprsp" to the Ninja command ("ninja -d keeprsp -v install") tells Ninja to leave the
        *.rsp files intact so we can look at them later, but I don't think there is any good way
        to add that "-d keeprsp" part to the command that runs during build.  It's possible to
        add it in a variety of ways (e.g., via Image File Execution Options tricks), but all of
        these are tricky and "mess with" the way that CMake is invoking Ninja, meaning it's
        "less clean" than just running "ninja -t compdb -x" after the fact as described above.)
      ]]


    Again, the content in

        m:\Z\NascentNotes\NetCore\BuildSystem\2022\Ref\001_ReferenceOnNinjaTraitsAndBuildIntegration.txt

    contains the most concrete information on the experiments that led to the conclusion
    discussed above (plus general information about the exact way that Ninja is invoked by
    the broader build and the exact environment in which each of these invocations occurs).



    #

    Ref on the nature of compile_commands.json:

        {https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html}

          [[
            If enabled, generates a compile_commands.json file containing the exact compiler calls
            for all translation units of the project in machine-readable form.
          ]]



    #

    In ninja:

      [[
        $ "c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\CMake\Ninja\ninja.exe" -h 2>&1 | findstr /i verbose
          -v, --verbose  show all command lines while building
      ]]



        #

        The discussion at

            https://github.com/ninja-build/ninja/issues/900

        points to the change at

            https://github.com/Kitware/CMake/commit/ce935ebe50926bde199d86fbde4a78974a4043f9

        which nominally automatically passes "-v" to ninja if CMAKE_VERBOSE_MAKEFILE is enabled,
        with the "Aug 18, 2015" comment on the GitHub issue saying that "configuring with
        -DCMAKE_VERBOSE_MAKEFILE=ON" will make this happen.

        Experiments show that this automatic "-v" argument is also passed whenever VERBOSE=1 is
        set in the environment.



        #

        The change at

            https://github.com/ninja-build/ninja/pull/1479

        would have added an additional "-x" switch which expands rsp file content in verbose
        output, but this change was never merged.



        #

        The change at

            https://github.com/ninja-build/ninja/pull/1223

        added an "-x" switch that can be used to force "ninja -t compdb -x" to generate the
        build command database in a form where all *.rsp references are expanded inline
        (generating entries that are "self-contained" and do not contain any references to
        immediately-deleted temporary *.rsp files, with the caveat that the listed command lines
        maybe unrunnable due to excessive length).

        The discussion associated with this PR points out the "-d keeprsp" can be prepended to
        most/all *.rsp-generating Ninja commands, and has the effect of telling Ninja to "leave
        the file lying around" instead of immediately deleting it like normal.

        Note that the RSP_FILE directives across the generated build.ninja files seem to be
        a comprehensive summary of all of the *.rsp files that are generated during the build.

        For more information, see the discussion and experiments in:

            m:\Z\NascentNotes\NetCore\BuildSystem\2022\Ref\001_ReferenceOnNinjaTraitsAndBuildIntegration.txt



    #

    As mentioned in the --verbose discussion below, CMake nominally supports a "VERBOSE"
    envvar.

    Experiments show that when VERBOSE=1 is present in the environment, CMake automatically
    passes a "-v" argument when invoking the Ninja build command (i.e., the command which
    synchronously invokes all of the command lines implied by the build.ninja build system
    definition).

    Ref:

        {https://cmake.org/cmake/help/latest/envvar/VERBOSE.html#envvar:VERBOSE}

          [[
            Activates verbose output from CMake and your build tools of choice when you start to
            actually build your project.

            Note that any given value is ignored. It's just checked for existence.
          ]]



    #

    The "--verbose" command line switch is targeted at printing full command lines, but is
    specifically scoped to "--build" operations.

    The build-runtime.cmd logic flows the ambient "CMakeArgs" through to the CMake operation
    executed in gen-buildsys.cmd (where this is NOT a "--build" operation).

    Later, the build-runtime.cmd logic triggers a CMake "--build" operation, but does not
    flow "CMakeArgs" or any other "user-configurable" CMake arguments through at that time.

    Ref:

        {https://cmake.org/cmake/help/latest/manual/cmake.1.html}

          [[
            Build a Project

            CMake provides a command-line signature to build an already-generated project binary
            tree:

                cmake --build <dir>             [<options>] [-- <build-tool-options>]
                cmake --build --preset <preset> [<options>] [-- <build-tool-options>]

            This abstracts a native build tool's command-line interface with the following options:

                --build <dir>

                    Project binary directory to be built.

                    This is required (unless a preset is specified) and must be first.

                ...

                -v, --verbose

                    Enable verbose output (if supported) including the build commands to be executed.

                    This option can be omitted if VERBOSE environment variable or CMAKE_VERBOSE_MAKEFILE
                    cached variable is set.

                --

                    Pass remaining options to the native tool.

            Run cmake --build with no options for quick help.
          ]]





#NATURE_OF_NOTARGETS_SDK

Nature of the NoTargets SDK:



    #

    {l:\Git\github\Microsoft\MSBuildSdks\src\NoTargets\README.md}

      [[
        The `Microsoft.Build.NoTargets` MSBuild project SDK allows project tree owners the
        ability to define projects that do not compile an assembly.

        This can be useful for utility projects that just copy files, build packages, or any
        other function where an assembly is not compiled.
      ]]








#NATURE_OF_DIRECTORY_DOT_BUILD_FILES

Nature of Directory.Build.* files:



    #

    {https://learn.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2019#directorybuildprops-and-directorybuildtargets}

      [[
        You can add a new property to every project by defining it in a single file called
        Directory.Build.props in the root folder that contains your source.

        When MSBuild runs, Microsoft.Common.props searches your directory structure for the
        Directory.Build.props file (and Microsoft.Common.targets looks for
        Directory.Build.targets).

        If it finds one, it imports the file and reads the properties defined within it.

        Directory.Build.props is a user-defined file that provides customizations to projects
        under a directory.
      ]]



    #

    {l:\Git\github\dotnet\msbuild\src\Tasks\Microsoft.Common.props}

      [[

        <PropertyGroup>


            ...



            <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">
                true
            </ImportDirectoryBuildProps>


        </PropertyGroup>



        //
        // <InOriginal>
        //
        // Determine the path to the directory build props file if the user did not disable
        // $(ImportDirectoryBuildProps) and they did not already specify an absolute path to use
        // via $(DirectoryBuildPropsPath).
        //
        // </InOriginal>
        //

        <PropertyGroup
            Condition="
                    '$(ImportDirectoryBuildProps)' == 'true'
                and
                    '$(DirectoryBuildPropsPath)' == ''
            "
        >


            <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">
                Directory.Build.props
            </_DirectoryBuildPropsFile>



            <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">
                $(
                    [MSBuild]::GetDirectoryNameOfFileAbove(
                        $(MSBuildProjectDirectory),
                        '$(_DirectoryBuildPropsFile)'
                    )
                )
            </_DirectoryBuildPropsBasePath>



            <DirectoryBuildPropsPath
                Condition="
                        '$(_DirectoryBuildPropsBasePath)' != ''
                    and
                        '$(_DirectoryBuildPropsFile)' != ''
                "
            >

                $(
                    [System.IO.Path]::Combine(
                        '$(_DirectoryBuildPropsBasePath)',
                        '$(_DirectoryBuildPropsFile)'
                    )
                )

            </DirectoryBuildPropsPath>


        </PropertyGroup> // End of: <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">



        <Import Project="$(DirectoryBuildPropsPath)"
            Condition="
                    '$(ImportDirectoryBuildProps)' == 'true'
                and
                    exists('$(DirectoryBuildPropsPath)')
            "
        />

      ]]





#

Ref on interpreting a NativeAOT linker command:

  [[
        //
        // Ref:
        //      l:\Git\github\LakshanF\dotnet\runtime\src\coreclr\nativeaot\BuildIntegration\NativeAOT.natvis
        //
        // Ref:
        //      /NATVIS:..\..\..\..\nativeaot\\BuildIntegration\NativeAOT.natvis
        //
        // Suggests:
        //            ..\..\..\.. = l:\Git\github\LakshanF\dotnet\runtime\src\coreclr
        //         ..\..\..\..\.. = l:\Git\github\LakshanF\dotnet\runtime\src
        //      ..\..\..\..\..\.. = l:\Git\github\LakshanF\dotnet\runtime
        //
        // If CWD was
        //
        //      C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot\ILCompiler\reproNative
        //
        // then the associated ".." escapes would be
        //
        //                     .. = C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot\ILCompiler
        //                  ..\.. = C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot
        //               ..\..\.. = C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools
        //            ..\..\..\.. = C:\Work\Core\CurrentWork3\runtime\src\coreclr
        //         ..\..\..\..\.. = C:\Work\Core\CurrentWork3\runtime\src
        //      ..\..\..\..\..\.. = C:\Work\Core\CurrentWork3\runtime
        //


    C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31933\bin\HostX64\x64\link.exe
        /ERRORREPORT:PROMPT
        /OUT:"C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot\ILCompiler\reproNative\x64\Debug\reproNative.exe"
        /INCREMENTAL:NO
        /NOLOGO
        /NATVIS:..\..\..\..\nativeaot\\BuildIntegration\NativeAOT.natvis
        ..\..\..\..\..\..\artifacts\bin\repro\x64\Debug\repro.obj
        advapi32.lib
        bcrypt.lib
        crypt32.lib
        iphlpapi.lib
        kernel32.lib
        mswsock.lib
        ncrypt.lib
        normaliz.lib
        ntdll.lib
        ole32.lib
        oleaut32.lib
        secur32.lib
        user32.lib
        version.lib
        ws2_32.lib
        kernel32.lib
        user32.lib
        gdi32.lib
        winspool.lib
        comdlg32.lib
        advapi32.lib
        shell32.lib
        ole32.lib
        oleaut32.lib
        uuid.lib
        odbc32.lib
        odbccp32.lib
        ..\..\..\..\..\..\artifacts\bin\coreclr\windows.x64.Debug\aotsdk\Runtime.WorkstationGC.lib
        ..\..\..\..\..\..\artifacts\bin\coreclr\windows.x64.Debug\aotsdk\System.Globalization.Native.Aot.lib
        /MANIFEST
        /MANIFESTUAC:"level='asInvoker'
        uiAccess='false'"
        /manifest:embed
        /DEBUG
        /PDB:"C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot\ILCompiler\reproNative\x64\Debug\reproNative.pdb"
        /SUBSYSTEM:CONSOLE
        /TLBID:1
        /DYNAMICBASE
        /NXCOMPAT
        /IMPLIB:"C:\Work\Core\CurrentWork3\runtime\src\coreclr\tools\aot\ILCompiler\reproNative\x64\Debug\reproNative.lib"
        /MACHINE:X64
        x64\Debug\main.obj

  ]]






{l:\Git\github\dotnet\runtime\build.cmd}


{
    @echo off



    setlocal



    set _args=%*



    if "%~1" == "-?" (
        set _args=-help
    )



    if "%~1" == "/?" (
        set _args=-help
    )



    powershell ^
        -ExecutionPolicy ByPass ^
        -NoProfile ^
        -Command
            "& '%~dp0eng\build.ps1'" %_args%



    exit /b %ERRORLEVEL%
}







{l:\Git\github\dotnet\runtime\eng\build.ps1}


{
    [CmdletBinding(PositionalBinding=$false)]
    Param(

        [switch][Alias('h')]$help,

        [switch][Alias('t')]$test,

        [ValidateSet("Debug","Release","Checked")][string[]][Alias('c')]$configuration = @("Debug"),

        [string][Alias('f')]$framework,

        [string]$vs,

        [string][Alias('v')]$verbosity = "minimal",

        [ValidateSet("windows","Linux","OSX","Android","Browser")][string]$os,

        [switch]$allconfigurations,

        [switch]$coverage,

        [string]$testscope,

        [switch]$testnobuild,

        [ValidateSet("x86","x64","arm","arm64","wasm")][string[]][Alias('a')]$arch = @([System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture.ToString().ToLowerInvariant()),

        [Parameter(Position=0)][string][Alias('s')]$subset,

        [ValidateSet("Debug","Release","Checked")][string][Alias('rc')]$runtimeConfiguration,

        [ValidateSet("Debug","Release")][string][Alias('lc')]$librariesConfiguration,

        [ValidateSet("CoreCLR","Mono")][string][Alias('rf')]$runtimeFlavor,

        [ValidateSet("Debug","Release","Checked")][string][Alias('hc')]$hostConfiguration,

        [switch]$ninja,

        [switch]$msbuild,

        [string]$cmakeargs,

        [switch]$pgoinstrument,

        [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
    )



    function Get-Help()
    {


        Write-Host "Common settings:"
        Write-Host "  -arch (-a)                     Target platform: x86, x64, arm, arm64, or wasm."
        Write-Host "                                 Pass a comma-separated list to build for multiple architectures."
        Write-Host "                                 [Default: Your machine's architecture.]"
        Write-Host "  -binaryLog (-bl)               Output binary log."
        Write-Host "  -configuration (-c)            Build configuration: Debug, Release or Checked."
        Write-Host "                                 Checked is exclusive to the CLR subset. It is the same as Debug, except code is"
        Write-Host "                                 compiled with optimizations enabled."
        Write-Host "                                 Pass a comma-separated list to build for multiple configurations."
        Write-Host "                                 [Default: Debug]"
        Write-Host "  -help (-h)                     Print help and exit."
        Write-Host "  -hostConfiguration (-hc)       Host build configuration: Debug, Release or Checked."
        Write-Host "                                 [Default: Debug]"
        Write-Host "  -librariesConfiguration (-lc)  Libraries build configuration: Debug or Release."
        Write-Host "                                 [Default: Debug]"
        Write-Host "  -os                            Target operating system: windows, Linux, OSX, Android or Browser."
        Write-Host "                                 [Default: Your machine's OS.]"
        Write-Host "  -runtimeConfiguration (-rc)    Runtime build configuration: Debug, Release or Checked."
        Write-Host "                                 Checked is exclusive to the CLR runtime. It is the same as Debug, except code is"
        Write-Host "                                 compiled with optimizations enabled."
        Write-Host "                                 [Default: Debug]"
        Write-Host "  -runtimeFlavor (-rf)           Runtime flavor: CoreCLR or Mono."
        Write-Host "                                 [Default: CoreCLR]"
        Write-Host "  -subset (-s)                   Build a subset, print available subsets with -subset help."
        Write-Host "                                 '-subset' can be omitted if the subset is given as the first argument."
        Write-Host "                                 [Default: Builds the entire repo.]"
        Write-Host "  -verbosity (-v)                MSBuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]."
        Write-Host "                                 [Default: Minimal]"
        Write-Host "  -vs                            Open the solution with Visual Studio using the locally acquired SDK."
        Write-Host "                                 Path or any project or solution name is accepted."
        Write-Host "                                 (Example: -vs Microsoft.CSharp or -vs CoreCLR.sln)"
        Write-Host ""

        Write-Host "Actions (defaults to -restore -build):"
        Write-Host "  -build (-b)             Build all source projects."
        Write-Host "                          This assumes -restore has been run already."
        Write-Host "  -clean                  Clean the solution."
        Write-Host "  -pack                   Package build outputs into NuGet packages."
        Write-Host "  -publish                Publish artifacts (e.g. symbols)."
        Write-Host "                          This assumes -build has been run already."
        Write-Host "  -rebuild                Rebuild all source projects."
        Write-Host "  -restore                Restore dependencies."
        Write-Host "  -sign                   Sign build outputs."
        Write-Host "  -test (-t)              Incrementally builds and runs tests."
        Write-Host "                          Use in conjunction with -testnobuild to only run tests."
        Write-Host ""

        Write-Host "Libraries settings:"
        Write-Host "  -allconfigurations      Build packages for all build configurations."
        Write-Host "  -coverage               Collect code coverage when testing."
        Write-Host "  -framework (-f)         Build framework: net8.0 or net48."
        Write-Host "                          [Default: net8.0]"
        Write-Host "  -testnobuild            Skip building tests when invoking -test."
        Write-Host "  -testscope              Scope tests, allowed values: innerloop, outerloop, all."
        Write-Host ""

        Write-Host "Native build settings:"
        Write-Host "  -cmakeargs              User-settable additional arguments passed to CMake."
        Write-Host "  -ninja                  Use Ninja to drive the native build. (default)"
        Write-Host "  -msbuild                Use MSBuild to drive the native build. This is a no-op for Mono."
        Write-Host "  -pgoinstrument          Build the CLR with PGO instrumentation."

        Write-Host "Command-line arguments not listed above are passed through to MSBuild."
        Write-Host "The above arguments can be shortened as much as to be unambiguous."
        Write-Host "(Example: -con for configuration, -t for test, etc.)."
        Write-Host ""

        Write-Host "Here are some quick examples. These assume you are on a Windows x64 machine:"
        Write-Host ""
        Write-Host "* Build CoreCLR for Windows x64 on Release configuration:"
        Write-Host ".\build.cmd clr -c release"
        Write-Host ""
        Write-Host "* Cross-compile CoreCLR runtime for Windows ARM64 on Release configuration."
        Write-Host ".\build.cmd clr.runtime -arch arm64 -c release"
        Write-Host ""
        Write-Host "* Build Debug libraries with a Release runtime for Windows x64."
        Write-Host ".\build.cmd clr+libs -rc release"
        Write-Host ""
        Write-Host "* Build Release libraries and their tests with a Checked runtime for Windows x64, and run the tests."
        Write-Host ".\build.cmd clr+libs+libs.tests -rc checked -lc release -test"
        Write-Host ""
        Write-Host "* Build Mono runtime for Windows x64 on Release configuration."
        Write-Host ".\build.cmd mono -c release"
        Write-Host ""
        Write-Host "* Build Release coreclr corelib, crossgen corelib and update Debug libraries testhost to run test on an updated corelib."
        Write-Host ".\build.cmd clr.corelib+clr.nativecorelib+libs.pretest -rc release"
        Write-Host ""
        Write-Host "* Build Debug mono corelib and update Release libraries testhost to run test on an updated corelib."
        Write-Host ".\build.cmd mono.corelib+libs.pretest -rc debug -c release"
        Write-Host ""
        Write-Host ""
        Write-Host "For more information, check out https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md"



        return;


    } // End of: function Get-Help()



    if ($help)
    {


        Get-Help



        exit 0


    } // End of: if ($help)



    if ($subset -eq 'help')
    {


        Invoke-Expression
            "& `"$PSScriptRoot/common/build.ps1`" -restore -build /p:subset=help /clp:nosummary"



        exit 0


    } // End of: if ($subset -eq 'help')



    if ($vs)
    {


        $archToOpen = $arch[0]



        $configToOpen = $configuration[0]



        $repoRoot = Split-Path $PSScriptRoot -Parent



        if ($runtimeConfiguration)
        {


            $configToOpen = $runtimeConfiguration


        } // End of: if ($runtimeConfiguration)



        if ($vs -ieq "coreclr.sln")
        {


            //
            // <InOriginal>
            //
            // If someone passes in coreclr.sln (case-insensitive), launch the generated CMake
            // solution.
            //
            // </InOriginal>
            //
            ;



            $vs =
                    Split-Path $PSScriptRoot -Parent
                |
                    Join-Path -ChildPath "artifacts\obj\coreclr"
                |
                    Join-Path -ChildPath "windows.$archToOpen.$((Get-Culture).TextInfo.ToTitleCase($configToOpen))"
                |
                    Join-Path -ChildPath "ide"
                |
                    Join-Path -ChildPath "CoreCLR.sln"



            if (-Not (Test-Path $vs))
            {


                Invoke-Expression
                    "& `"$repoRoot/src/coreclr/build-runtime.cmd`" -configureonly -$archToOpen -$configToOpen -msbuild"



                if ($lastExitCode -ne 0)
                {


                    Write-Error "Failed to generate the CoreCLR solution file."



                    exit 1


                } // End of: if ($lastExitCode -ne 0)



                if (-Not (Test-Path $vs))
                {


                    Write-Error "Unable to find the CoreCLR solution file at $vs."


                } // End of: if (-Not (Test-Path $vs))


            } // End of: if (-Not (Test-Path $vs))


        }
        else // I.e., if (!($vs -ieq "coreclr.sln"))
        {


            if ($vs -ieq "corehost.sln")
            {


                $vs =
                        Split-Path $PSScriptRoot -Parent
                    |
                        Join-Path -ChildPath "artifacts\obj\"
                    |
                        Join-Path -ChildPath "win-$archToOpen.$((Get-Culture).TextInfo.ToTitleCase($configToOpen))"
                    |
                        Join-Path -ChildPath "corehost"
                    |
                        Join-Path -ChildPath "ide"
                    |
                        Join-Path -ChildPath "corehost.sln"



                if (-Not (Test-Path $vs))
                {


                    Invoke-Expression
                        "& `"$repoRoot/eng/common/msbuild.ps1`" $repoRoot/src/native/corehost/corehost.proj /clp:nosummary /restore /p:Ninja=false /p:Configuration=$configToOpen /p:TargetArchitecture=$archToOpen /p:ConfigureOnly=true"



                    if ($lastExitCode -ne 0)
                    {


                        Write-Error "Failed to generate the CoreHost solution file."



                        exit 1


                    } // End of: if ($lastExitCode -ne 0)



                    if (-Not (Test-Path $vs))
                    {


                        Write-Error "Unable to find the CoreHost solution file at $vs."


                    } // End of: if (-Not (Test-Path $vs))


                } // End of: if (-Not (Test-Path $vs))


            }
            else // I.e., if (!($vs -ieq "corehost.sln"))
            {


                if (-Not (Test-Path $vs))
                {


                    $solution = $vs



                    if ($runtimeFlavor -eq "Mono")
                    {


                        //
                        // <InOriginal>
                        // Search for the solution in mono.
                        // </InOriginal>
                        //

                        $vs =
                                Split-Path $PSScriptRoot -Parent
                            |
                                Join-Path -ChildPath "src\mono"
                            |
                                Join-Path -ChildPath $vs
                            |
                                Join-Path -ChildPath "$vs.sln"


                    }
                    else // I.e., if (!($runtimeFlavor -eq "Mono"))
                    {


                        //
                        // <InOriginal>
                        // Search for the solution in coreclr.
                        // </InOriginal>
                        //

                        $vs =
                                Split-Path $PSScriptRoot -Parent
                            |
                                Join-Path -ChildPath "src\coreclr"
                            |
                                Join-Path -ChildPath $vs
                            |
                                Join-Path -ChildPath "$vs.sln"


                    } // End of: else // I.e., if (!($runtimeFlavor -eq "Mono"))



                    if (-Not (Test-Path $vs))
                    {


                        $vs = $solution



                        //
                        // <InOriginal>
                        // Search for the solution in libraries.
                        // </InOriginal>
                        //

                        $vs =
                                Split-Path $PSScriptRoot -Parent
                            |
                                Join-Path -ChildPath "src\libraries"
                            |
                                Join-Path -ChildPath $vs
                            |
                                Join-Path -ChildPath "$vs.sln"



                        if (-Not (Test-Path $vs))
                        {


                            $vs = $solution



                            //
                            // <InOriginal>
                            // Search for the solution in installer.
                            // </InOriginal>
                            //

                            if (-Not ($vs.endswith(".sln")))
                            {


                                $vs = "$vs.sln"


                            } // End of: if (-Not ($vs.endswith(".sln")))



                            $vs =
                                    Split-Path $PSScriptRoot -Parent
                                |
                                    Join-Path -ChildPath "src\installer"
                                |
                                    Join-Path -ChildPath $vs



                            if (-Not (Test-Path $vs))
                            {


                                Write-Error "Passed in solution cannot be resolved."



                                exit 1


                            } // End of: if (-Not (Test-Path $vs))


                        } // End of: if (-Not (Test-Path $vs))


                    } // End of: if (-Not (Test-Path $vs))


                } // End of: if (-Not (Test-Path $vs))


            } // End of: else // I.e., if (!($vs -ieq "corehost.sln"))


        } // End of: else // I.e., if (!($vs -ieq "coreclr.sln"))



        . $PSScriptRoot\common\tools.ps1



        //
        // <InOriginal>
        // This tells .NET Core to use the bootstrapped runtime.
        // </InOriginal>
        //

        $env:DOTNET_ROOT=(
            InitializeDotNetCli
                install: $true
                createSdkLocationFile: $true
        );



        //
        // <InOriginal>
        // This tells MSBuild to load the SDK from the directory of the bootstrapped SDK.
        // </InOriginal>
        //

        $env:DOTNET_MSBUILD_SDK_RESOLVER_CLI_DIR=$env:DOTNET_ROOT



        //
        // <InOriginal>
        // This tells .NET Core not to go looking for .NET Core in other places.
        // </InOriginal>
        //

        $env:DOTNET_MULTILEVEL_LOOKUP=0;



        //
        // <InOriginal>
        // Put our local dotnet.exe on PATH first so Visual Studio knows which one to use.
        // </InOriginal>
        //

        $env:PATH=($env:DOTNET_ROOT + ";" + $env:PATH);



        if ($runtimeConfiguration)
        {


            //
            // <InOriginal>
            //
            // Respect the RuntimeConfiguration variable for building inside VS with different runtime
            // configurations.
            //
            // </InOriginal>
            //

            $env:RUNTIMECONFIGURATION=$runtimeConfiguration


        } // End of: if ($runtimeConfiguration)



        //
        // <InOriginal>
        // Launch Visual Studio with the locally defined environment variables.
        // </InOriginal>
        //

        ."$vs"

        exit 0


    } // End of: if ($vs)



    //
    // <InOriginal>
    // Check if an action is passed in.
    // </InOriginal>
    //
    ;



    $actions =
        "b", "build",
        "r", "restore",
        "rebuild",
        "sign",
        "testnobuild",
        "publish",
        "clean"



    $actionPassedIn = (

            @(
                Compare-Object
                    -ReferenceObject @($PSBoundParameters.Keys)
                    -DifferenceObject $actions
                    -ExcludeDifferent
                    -IncludeEqual
            ).Length

        -ne

            0
    );



    if ($actionPassedIn -ne $true)
    {


        if ($properties -ne null)
        {


            $actionPassedIn = (

                    @(
                        Compare-Object
                            -ReferenceObject $properties
                            -DifferenceObject $actions.ForEach({ "-" + $_ })
                            -ExcludeDifferent
                            -IncludeEqual
                    ).Length

                -ne

                    0
            );


        } // End of: if ($properties -ne null)


    } // End of: if ($actionPassedIn -ne $true)



    if (!$actionPassedIn)
    {


        $arguments = "-restore -build"


    } // End of: if (!$actionPassedIn)



    if ($PSBoundParameters.ContainsKey('os'))
    {


        if ($PSBoundParameters['os'] -eq "Browser")
        {


            //
            // <InOriginal>
            // Make sure it is capitalized.
            // </InOriginal>
            //

            $PSBoundParameters['os'] = "Browser"


        } // End of: if ($PSBoundParameters['os'] -eq "Browser")


    } // End of: if ($PSBoundParameters.ContainsKey('os'))



    foreach ($argument in $PSBoundParameters.Keys)
    {


        switch ($argument)
        {


            default
            {
                $arguments += " /p:$argument=$($PSBoundParameters[$argument])"
            }


            //
            // <InOriginal>
            // The -ninja switch is a no-op since Ninja is the default generator on Windows.
            // </InOriginal>
            //

            "ninja" {}


            //
            // <InOriginal>
            // configuration and arch can be specified multiple times, so they should be no-ops here.
            // </InOriginal>
            //

            "configuration" {}
            "arch" {}


            "runtimeConfiguration"
            {
                $arguments += " /p:RuntimeConfiguration=$((Get-Culture).TextInfo.ToTitleCase($($PSBoundParameters[$argument])))"
            }


            "runtimeFlavor"
            {
                $arguments += " /p:RuntimeFlavor=$($PSBoundParameters[$argument].ToLowerInvariant())"
            }


            "librariesConfiguration"
            {
                $arguments += " /p:LibrariesConfiguration=$((Get-Culture).TextInfo.ToTitleCase($($PSBoundParameters[$argument])))"
            }


            "hostConfiguration"
            {
                $arguments += " /p:HostConfiguration=$((Get-Culture).TextInfo.ToTitleCase($($PSBoundParameters[$argument])))"
            }


            "framework"
            {
                $arguments += " /p:BuildTargetFramework=$($PSBoundParameters[$argument].ToLowerInvariant())"
            }


            "os"
            {
                $arguments += " /p:TargetOS=$($PSBoundParameters[$argument])"
            }


            "allconfigurations"
            {
                $arguments += " /p:BuildAllConfigurations=true"
            }


            "properties"
            {
                $arguments += " " + $properties
            }


            "verbosity"
            {
                $arguments += " -$argument " + $($PSBoundParameters[$argument])
            }


            "cmakeargs"
            {
                $arguments += " /p:CMakeArgs=`"$($PSBoundParameters[$argument])`""
            }


            "msbuild"
            {
                $arguments += " /p:Ninja=false"
            }


            "pgoinstrument"
            {
                $arguments += " /p:PgoInstrument=$($PSBoundParameters[$argument])"
            }




        } // End of: switch ($argument)



        continue;


    } // End of: foreach ($argument in $PSBoundParameters.Keys)



    //
    // <InOriginal>
    //
    // Disable targeting pack caching as we reference a partially constructed targeting pack
    // and update it later.
    //
    // The later changes are ignored when using the cache.
    //
    // </InOriginal>
    //

    $env:DOTNETSDK_ALLOW_TARGETING_PACK_CACHING=0



    $failedBuilds = @()



    if ($os -eq "Browser")
    {


        //
        // <InOriginal>
        // Override default arch for Browser, we only support wasm.
        // </InOriginal>
        //

        $arch = "wasm"



        if ($msbuild -eq $True)
        {


            Write-Error "Using the -msbuild option isn't supported when building for Browser on Windows, we need need ninja for Emscripten."



            exit 1


        } // End of: if ($msbuild -eq $True)


    } // End of: if ($os -eq "Browser")



    foreach ($config in $configuration)
    {


        $argumentsWithConfig = (
                $arguments
            +
                " -configuration $((Get-Culture).TextInfo.ToTitleCase($config))"
        );



        foreach ($singleArch in $arch)
        {


            $argumentsWithArch = (
                    "/p:TargetArchitecture=$singleArch "
                +
                    $argumentsWithConfig
            );



            //
            // Set the __DistroRid that is consumed, e.g., in
            // {l:\Git\github\dotnet\runtime\Directory.Build.props}.
            //

            if ($os -eq "Browser")
            {


                $env:__DistroRid="browser-$singleArch"


            }
            else // I.e., if (!($os -eq "Browser"))
            {


                $env:__DistroRid="win-$singleArch"


            } // End of: else // I.e., if (!($os -eq "Browser"))



            //
            // Call out to eng\common\build.ps1.
            //
            // Ref:
            //
            //      l:\Git\github\dotnet\runtime $ where /r . build.ps1
            //      l:\Git\github\dotnet\runtime\eng\build.ps1
            //      l:\Git\github\dotnet\runtime\eng\common\build.ps1
            //

            Invoke-Expression
                "& `"$PSScriptRoot/common/build.ps1`" $argumentsWithArch"



            if ($lastExitCode -ne 0)
            {


                $failedBuilds += "Configuration: $config, Architecture: $singleArch"


            } // End of: if ($lastExitCode -ne 0)



            continue;


        } // End of: foreach ($singleArch in $arch)



        continue;


    } // End of: foreach ($config in $configuration)



    if ($failedBuilds.Count -ne 0)
    {


        Write-Host "Some builds failed:"



        foreach ($failedBuild in $failedBuilds)
        {


            Write-Host "`t$failedBuild"

            continue;


        } // End of: foreach ($failedBuild in $failedBuilds)



        exit 1


    } // End of: if ($failedBuilds.Count -ne 0)



    if ($ninja)
    {


        Write-Host "The -ninja option has no effect on Windows builds since the Ninja generator is the default generator."


    } // End of: if ($ninja)



    exit 0
}







{l:\Git\github\dotnet\runtime\eng\common\build.ps1}


{
    [CmdletBinding(PositionalBinding=$false)]
    Param(

        [string][Alias('c')]$configuration = "Debug",

        [string]$platform = $null,

        [string] $projects,

        [string][Alias('v')]$verbosity = "minimal",

        [string] $msbuildEngine = $null,

        [bool] $warnAsError = $true,

        [bool] $nodeReuse = $true,

        [switch][Alias('r')]$restore,

        [switch] $deployDeps,

        [switch][Alias('b')]$build,

        [switch] $rebuild,

        [switch] $deploy,

        [switch][Alias('t')]$test,

        [switch] $integrationTest,

        [switch] $performanceTest,

        [switch] $sign,

        [switch] $pack,

        [switch] $publish,

        [switch] $clean,

        [switch][Alias('bl')]$binaryLog,

        [switch][Alias('nobl')]$excludeCIBinarylog,

        [switch] $ci,

        [switch] $prepareMachine,

        [string] $runtimeSourceFeed = '',

        [string] $runtimeSourceFeedKey = '',

        [switch] $excludePrereleaseVS,

        [switch] $nativeToolsOnMachine,

        [switch] $help,

        [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
    )



    //
    // <InOriginal>
    //
    // Unset 'Platform' environment variable to avoid unwanted collision in
    // InstallDotNetCore.targets file.
    //
    // Some computers have this env var defined (e.g., some HP).
    //
    // </InOriginal>
    //

    if ($env:Platform)
    {


        $env:Platform=""


    } // End of: if ($env:Platform)



    function Print-Usage()
    {


        Write-Host "Common settings:"
        Write-Host "  -configuration <value>  Build configuration: 'Debug' or 'Release' (short: -c)"
        Write-Host "  -platform <value>       Platform configuration: 'x86', 'x64' or any valid Platform value to pass to msbuild"
        Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
        Write-Host "  -binaryLog              Output binary log (short: -bl)"
        Write-Host "  -help                   Print help and exit"
        Write-Host ""

        Write-Host "Actions:"
        Write-Host "  -restore                Restore dependencies (short: -r)"
        Write-Host "  -build                  Build solution (short: -b)"
        Write-Host "  -rebuild                Rebuild solution"
        Write-Host "  -deploy                 Deploy built VSIXes"
        Write-Host "  -deployDeps             Deploy dependencies (e.g. VSIXes for integration tests)"
        Write-Host "  -test                   Run all unit tests in the solution (short: -t)"
        Write-Host "  -integrationTest        Run all integration tests in the solution"
        Write-Host "  -performanceTest        Run all performance tests in the solution"
        Write-Host "  -pack                   Package build outputs into NuGet packages and Willow components"
        Write-Host "  -sign                   Sign build outputs"
        Write-Host "  -publish                Publish artifacts (e.g. symbols)"
        Write-Host "  -clean                  Clean the solution"
        Write-Host ""

        Write-Host "Advanced settings:"
        Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's to build. Globbing is supported (*.sln)"
        Write-Host "  -ci                     Set when running on CI server"
        Write-Host "  -excludeCIBinarylog     Don't output binary log (short: -nobl)"
        Write-Host "  -prepareMachine         Prepare machine for CI run, clean up processes after build"
        Write-Host "  -warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
        Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
        Write-Host "  -excludePrereleaseVS    Set to exclude build engines in prerelease versions of Visual Studio"
        Write-Host "  -nativeToolsOnMachine   Sets the native tools on machine environment variable (indicating that the script should use native tools on machine)"
        Write-Host ""

        Write-Host "Command line arguments not listed above are passed thru to msbuild."
        Write-Host "The above arguments can be shortened as much as to be unambiguous (e.g. -co for configuration, -t for test, etc.)."



        return;


    } // End of: function Print-Usage()



    . $PSScriptRoot\tools.ps1



    function InitializeCustomToolset
    {


        if (-not $restore)
        {
            return
        }



        $script =
            Join-Path $EngRoot 'restore-toolset.ps1'



        if (Test-Path $script)
        {


            . $script


        } // End of: if (Test-Path $script)



        return;


    } // End of: function InitializeCustomToolset



    function Build
    {


        //
        // Call out to eng\common\tools.ps1.
        //
        // As described in the callee listing, the returned path generally refers to the
        // {tools\Build.proj} file within the Microsoft.DotNet.Arcade.Sdk package, and therefore
        // refers to a copy of the file found at:
        //
        //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
        //

        $toolsetBuildProj = InitializeToolset



        InitializeCustomToolset



        $bl = (
           !($binaryLog)
                ?
                        ''
                    :
                        ( '/bl:' + (Join-Path $LogDir 'Build.binlog') )
        );



        $platformArg = (
           !($platform)
                ?
                        ''
                    :
                        "/p:Platform=$platform"
        );



        if ($projects)
        {


            //
            // <InOriginal>
            //
            // Re-assign properties to a new variable because PowerShell doesn't let us append
            // properties directly for unclear reasons.
            //
            // Explicitly set the type as string[] because otherwise PowerShell would make this char[]
            // if $properties is empty.
            //
            // </InOriginal>
            //

            [string[]] $msbuildArgs = $properties



            //
            // <InOriginal>
            // Resolve relative project paths into full paths.
            // </InOriginal>
            //

            $projects = (

                  $projects
                    .Split(';')
                    .ForEach({Resolve-Path $_})

                -join

                    ';'
            )



            $msbuildArgs += "/p:Projects=$projects"



            $properties = $msbuildArgs


        } // End of: if ($projects)



        //
        // Defer to callee code in the MSBuild-Core function which will
        //
        //    .
        //      take the msbuild runner tool located by InitializeBuildTool (as detailed at the
        //      different InitializeBuildTool callsites throughout these listings)
        //
        //    .
        //      and run it against the {tools\Build.proj} file within the Microsoft.DotNet.Arcade.Sdk
        //      package, i.e., a copy of the file found at:
        //
        //          {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
        //
        //    .
        //      with this invocation specifically being driven by the large set of arguments passed
        //      below (which include both the arguments specifically listed below plus the free-form
        //      "$properties" set which contains all of the "extra" arguments that were passed in from
        //      callers, e.g., from {l:\Git\github\dotnet\runtime\eng\build.ps1}).
        //
        //
        // As shown in the {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
        // file listing, applying the msbuild runner to the Arcade tools\Build.proj file will run
        // the default "Execute" target.
        //
        // As shown in the "Execute" target listing, in the dotnet/runtime case, all of the "core"
        // build steps will be executed by deferring to the {l:\Git\github\dotnet\runtime\Build.proj}
        // file, due to this *.proj file being listed as the "ProjectToBuild" setting in the
        // eng\Build.props file that is checked in to the dotnet/runtime repo.
        //
        // Ref:
        //
        //    [[
        //      $ type l:\Git\github\dotnet\runtime\eng\Build.props
        //      <Project>
        //        <PropertyGroup>
        //          <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
        //          <GenerateRestoreUseStaticGraphEvaluationBinlog>true</GenerateRestoreUseStaticGraphEvaluationBinlog>
        //        </PropertyGroup>
        //        <ItemGroup>
        //          <ProjectToBuild Include="$(RepoRoot)Build.proj" />
        //        </ItemGroup>
        //      </Project>
        //    ]]
        //
        //

        MSBuild `
            $toolsetBuildProj `
            $bl `
            $platformArg `
            /p:Configuration=$configuration `
            /p:RepoRoot=$RepoRoot `
            /p:Restore=$restore `
            /p:DeployDeps=$deployDeps `
            /p:Build=$build `
            /p:Rebuild=$rebuild `
            /p:Deploy=$deploy `
            /p:Test=$test `
            /p:Pack=$pack `
            /p:IntegrationTest=$integrationTest `
            /p:PerformanceTest=$performanceTest `
            /p:Sign=$sign `
            /p:Publish=$publish `
            @properties



        return;


    } // End of: function Build



    try
    {


        if ($clean)
        {


            if (Test-Path $ArtifactsDir)
            {


                Remove-Item
                    -Recurse
                    -Force $ArtifactsDir



                Write-Host 'Artifacts directory deleted.'


            } // End of: if (Test-Path $ArtifactsDir)



            exit 0


        } // End of: if ($clean)



        bool needToPrintUsage = (

                $help

            -or

                (
                        ($properties -ne $null)

                    -and

                        (
                                $properties.Contains('/help')
                            -or
                                $properties.Contains('/?')
                        )
                )
        );



        if (needToPrintUsage)
        {


            Print-Usage



            exit 0


        } // End of: if (needToPrintUsage)



        if ($ci)
        {


            if (-not $excludeCIBinarylog)
            {


                $binaryLog = $true


            } // End of: if (-not $excludeCIBinarylog)



            $nodeReuse = $false


        } // End of: if ($ci)



        if ($nativeToolsOnMachine)
        {


            $env:NativeToolsOnMachine = $true


        } // End of: if ($nativeToolsOnMachine)



        if ($restore)
        {


            InitializeNativeTools


        } // End of: if ($restore)



        Build


    }
    catch
    {


        Write-Host $_.ScriptStackTrace



        Write-PipelineTelemetryError
            -Category 'InitializeToolset'
            -Message $_



        ExitWithExitCode 1


    } // End of: catch



    ExitWithExitCode 0
}







{l:\Git\github\dotnet\runtime\eng\common\tools.ps1}


{
    //
    // Notes:
    //
    //    .
    //      A large number of crucial settings ($ToolsetDir, $GlobalJson, etc) are established in
    //      the top-level directives that are found at the very end of this file (and which
    //      therefore run unconditionally and automatically whenever this script is first loaded).
    //
    ;



    //
    // <InOriginal>
    //
    // Initialize variables if they aren't already defined.
    //
    // These may be defined as parameters of the importing script, or set after importing this
    // script.
    //
    // </InOriginal>
    //
    ;



    //
    // <InOriginal>
    // CI mode - set to true on CI server for PR validation build or official build.
    // </InOriginal>
    //

    [bool]$ci = (
       !(Test-Path variable:ci)
            ?
                    $false
                :
                    $ci
    );



    //
    // <InOriginal>
    //
    // Build configuration.
    //
    // Common values include 'Debug' and 'Release', but the repository may use other names.
    //
    // </InOriginal>
    //

    [string]$configuration = (
       !(Test-Path variable:configuration)
            ?
                    'Debug'
                :
                    $configuration
    );



    //
    // <InOriginal>
    // Set to true to opt out of outputting binary log while running in CI.
    // </InOriginal>
    //

    [bool]$excludeCIBinarylog = (
       !(Test-Path variable:excludeCIBinarylog)
            ?
                    $false
                :
                    $excludeCIBinarylog
    );



    //
    // <InOriginal>
    //
    // Set to true to output binary log from msbuild.
    //
    // Note that emitting binary log slows down the build.
    //
    // </InOriginal>
    //

    [bool]$binaryLog = (
       !(Test-Path variable:binaryLog)
            ?
                    (($ci -and !$excludeCIBinarylog) ? true : false)
                :
                    $binaryLog
    );



    //
    // <InOriginal>
    //
    // Set to true to use the pipelines logger which will enable Azure logging output.
    //
    // See: https://github.com/Microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md
    //
    // This flag is meant as a temporary opt-opt for the feature while validate it across our
    // consumers.
    //
    // It will be deleted in the future.
    //
    // </InOriginal>
    //

    [bool]$pipelinesLog = (
       !(Test-Path variable:pipelinesLog)
            ?
                    ($ci ? true : false)
                :
                    $pipelinesLog
    );



    //
    // <InOriginal>
    //
    // Turns on machine preparation/clean up code that changes the machine state (e.g., kills
    // build processes).
    //
    // </InOriginal>
    //

    [bool]$prepareMachine = (
       !(Test-Path variable:prepareMachine)
            ?
                    $false
                :
                    $prepareMachine
    );



    //
    // <InOriginal>
    // True to restore toolsets and dependencies.
    // </InOriginal>
    //

    [bool]$restore = (
       !(Test-Path variable:restore)
            ?
                    $true
                :
                    $restore
    );



    //
    // <InOriginal>
    // Adjusts msbuild verbosity level.
    // </InOriginal>
    //

    [string]$verbosity = (
       !(Test-Path variable:verbosity)
            ?
                    'minimal'
                :
                    $verbosity
    );



    //
    // <InOriginal>
    //
    // Set to true to reuse msbuild nodes.
    //
    // Recommended to not reuse on CI.
    //
    // </InOriginal>
    //

    [bool]$nodeReuse = (
       !(Test-Path variable:nodeReuse)
            ?
                    ($ci ? false : true)
                :
                    $nodeReuse
    );



    //
    // <InOriginal>
    // Configures warning treatment in msbuild.
    // </InOriginal>
    //

    [bool]$warnAsError = (
       !(Test-Path variable:warnAsError)
            ?
                    $true
                :
                    $warnAsError
    );



    //
    // <InOriginal>
    //
    // Specifies which msbuild engine to use for build: 'vs', 'dotnet' or unspecified.
    //
    // This is determined based on presence of tools.vs in global.json.
    //
    // </InOriginal>
    //

    [string]$msbuildEngine = (
       !(Test-Path variable:msbuildEngine)
            ?
                    $null
                :
                    $msbuildEngine
    );



    //
    // <InOriginal>
    //
    // True to attempt using any .NET Core that meets requirements specified in global.json and
    // is already installed on the machine instead of downloading one.
    //
    // </InOriginal>
    //

    [bool]$useInstalledDotNetCli = (
       !(Test-Path variable:useInstalledDotNetCli)
            ?
                    $true
                :
                    $useInstalledDotNetCli
    );



    //
    // <InOriginal>
    //
    // Enable repos to use a particular version of the on-line dotnet-install scripts.
    //
    // Default URL: https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.ps1
    //
    // </InOriginal>
    //

    [string]$dotnetInstallScriptVersion = (
       !(Test-Path variable:dotnetInstallScriptVersion)
            ?
                    'v1'
                :
                    $dotnetInstallScriptVersion
    );



    //
    // <InOriginal>
    //
    // True to use global NuGet cache instead of restoring packages to repository-local
    // directory.
    //
    // </InOriginal>
    //

    [bool]$useGlobalNuGetCache = (
       !(Test-Path variable:useGlobalNuGetCache)
            ?
                    ($ci ? false : true)
                :
                    $useGlobalNuGetCache
    );



    //
    // <InOriginal>
    // True to exclude prerelease versions Visual Studio during build.
    // </InOriginal>
    //

    [bool]$excludePrereleaseVS = (
       !(Test-Path variable:excludePrereleaseVS)
            ?
                    $false
                :
                    $excludePrereleaseVS
    );



    //
    // <InOriginal>
    // An array of names of processes to stop on script exit if prepareMachine is true.
    // </InOriginal>
    //

    $processesToStopOnExit = (
       !(Test-Path variable:processesToStopOnExit)
            ?
                    @('msbuild', 'dotnet', 'vbcscompiler')
                :
                    $processesToStopOnExit
    );



    $disableConfigureToolsetImport = (
       !(Test-Path variable:disableConfigureToolsetImport)
            ?
                    $null
                :
                    $disableConfigureToolsetImport
    );



    set-strictmode -version 2.0



    $ErrorActionPreference = 'Stop'



    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12



    //
    // <InOriginal>
    //
    // If specified, provides an alternate path for getting .NET Core SDKs and Runtimes.
    //
    // This script will still try public sources first.
    //
    // </InOriginal>
    //

    [string]$runtimeSourceFeed = (
       !(Test-Path variable:runtimeSourceFeed)
            ?
                    $null
                :
                    $runtimeSourceFeed
    );



    //
    // <InOriginal>
    //
    // Base-64 encoded SAS token that has permission to storage container described by
    // $runtimeSourceFeed.
    //
    // </InOriginal>
    //

    [string]$runtimeSourceFeedKey = (
       !(Test-Path variable:runtimeSourceFeedKey)
            ?
                    $null
                :
                    $runtimeSourceFeedKey
    );



    function Create-Directory ([string[]] $path)
    {

            New-Item
                -Path $path
                -Force
                -ItemType 'Directory'
        |
            Out-Null



        return;


    } // End of: function Create-Directory ([string[]] $path)



    function Unzip([string]$zipfile, [string]$outpath)
    {


        Add-Type
            -AssemblyName System.IO.Compression.FileSystem



        [System.IO.Compression.ZipFile]::ExtractToDirectory(
            $zipfile,
            $outpath
        )



        return;


    } // End of: function Unzip([string]$zipfile, [string]$outpath)



    //
    // <InOriginal>
    //
    // This will exec a process using the console and return it's exit code.
    //
    // This will not throw when the process fails.
    //
    // Returns process exit code.
    //
    // </InOriginal>
    //

    function Exec-Process([string]$command, [string]$commandArgs)
    {


        $startInfo =
            New-Object System.Diagnostics.ProcessStartInfo



        $startInfo.FileName = $command



        $startInfo.Arguments = $commandArgs



        $startInfo.UseShellExecute = $false



        $startInfo.WorkingDirectory = Get-Location



        $process =
            New-Object System.Diagnostics.Process



        $process.StartInfo = $startInfo



            $process.Start()
        |
            Out-Null



        $finished = $false



        try
        {


            while (-not $process.WaitForExit(100))
            {


                //
                // <InOriginal>
                // Non-blocking loop done to allow ctrl-c interrupts.
                // </InOriginal>
                //

                continue;


            } // End of: while (-not $process.WaitForExit(100))



            $finished = $true



            return (
                $global:LASTEXITCODE = $process.ExitCode
            );


        }
        finally
        {


            //
            // <InOriginal>
            //
            // If we didn't finish then an error occurred or the user hit ctrl-c.
            //
            // Either way, kill the process.
            //
            // </InOriginal>
            //

            if (-not $finished)
            {


                $process.Kill()


            } // End of: if (-not $finished)


        } // End of: finally



        UNREACHABLE();


    } // End of: function Exec-Process([string]$command, [string]$commandArgs)



    //
    // <InOriginal>
    //
    // #
    //
    // Take the given block, print it, print what the block probably references from the
    // current set of variables using low-effort string matching, then run the block.
    //
    //
    //
    // #
    //
    // This is intended to replace the pattern of manually copy-pasting a command, wrapping it
    // in quotes, and printing it using "Write-Host".
    //
    // The copy-paste method is more readable in build logs, but less maintainable and less
    // reliable.
    //
    // It is easy to make a mistake and modify the command without properly updating the
    // "Write-Host" line, resulting in misleading build logs.
    //
    // The probability of this mistake makes the pattern hard to trust when it shows up in
    // build logs.
    //
    // Finding the bug in existing source code can also be difficult, because the strings are
    // not aligned to each other and the line may be 300+ columns long.
    //
    //
    // #
    //
    // By removing the need to maintain two copies of the command, Exec-BlockVerbosely avoids
    // the issues.
    //
    //
    // #
    //
    // In Bash (or any posix-like shell), "set -x" prints usable verbose output automatically.
    //
    // "Set-PSDebug" appears to be similar at first glance, but unfortunately, it isn't very
    // useful: it doesn't print any info about the variables being used by the command, which
    // is normally the interesting part to diagnose.
    //
    // </InOriginal>
    //

    function Exec-BlockVerbosely([scriptblock] $block)
    {


        Write-Host "--- Running script block:"



        $blockString =
          $block
            .ToString()
            .Trim()



        Write-Host $blockString



        Write-Host "--- List of variables that might be used:"



        //
        // <InOriginal>
        //
        // For each variable x in the environment, check the block for a reference to x via simple
        // "$x" or "@x" syntax.
        //
        // This doesn't detect other ways to reference variables ("${x}" nor "$variable:x", among
        // others).
        //
        // It only catches what this function was originally written for: simple command-line
        // commands.
        //
        // </InOriginal>
        //
        ;



        $variableTable =
                Get-Variable
            |
                Where-Object {
                        $blockString.Contains("`$$($_.Name)")
                    -or
                        $blockString.Contains("@$($_.Name)")
                }
            |
                Format-Table
                    -AutoSize
                    -HideTableHeaders
                    -Wrap
            |
                Out-String



        Write-Host $variableTable.Trim()



        Write-Host "--- Executing:"



        & $block



        Write-Host "--- Done running script block!"



        return;


    } // End of: function Exec-BlockVerbosely([scriptblock] $block)



    //
    // <InOriginal>
    //
    // The "createSdkLocationFile" parameter enables a file being generated under the toolset
    // directory which this code writes the sdk's location into.
    //
    // This is only necessary for "cmd -> powershell" invocations as dot sourcing isn't
    // possible.
    //
    // </InOriginal>
    //

    function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile)
    {


        if (Test-Path variable:global:_DotNetInstallDir)
        {
            return $global:_DotNetInstallDir
        }



        //
        // <InOriginal>
        //
        // Don't resolve runtime, shared framework, or SDK from other locations to ensure build
        // determinism.
        //
        // </InOriginal>
        //

        $env:DOTNET_MULTILEVEL_LOOKUP=0



        //
        // <InOriginal>
        // Disable first run since we do not need all ASP.NET packages restored.
        // </InOriginal>
        //

        $env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1



        //
        // <InOriginal>
        // Disable telemetry on CI.
        // </InOriginal>
        //

        if ($ci)
        {


            $env:DOTNET_CLI_TELEMETRY_OPTOUT=1


        } // End of: if ($ci)



        //
        // <InOriginal>
        // Source Build uses DotNetCoreSdkDir variable.
        // </InOriginal>
        //

        if ($env:DotNetCoreSdkDir -ne $null)
        {


            $env:DOTNET_INSTALL_DIR = $env:DotNetCoreSdkDir


        } // End of: if ($env:DotNetCoreSdkDir -ne $null)



        //
        // <InOriginal>
        // Find the first path on %PATH% that contains the dotnet.exe.
        // </InOriginal>
        //
        ;



        bool needToSearchForDotnetDotExeOnThePath = (
                $useInstalledDotNetCli
            -and
                (-not $globalJsonHasRuntimes)
            -and
                ($env:DOTNET_INSTALL_DIR -eq $null)
        );



        if (needToSearchForDotnetDotExeOnThePath)
        {


            $dotnetExecutable =
                GetExecutableFileName 'dotnet'



            $dotnetCmd =
                Get-Command
                    $dotnetExecutable
                    -ErrorAction SilentlyContinue



            if ($dotnetCmd -ne $null)
            {


                $env:DOTNET_INSTALL_DIR = Split-Path $dotnetCmd.Path -Parent


            } // End of: if ($dotnetCmd -ne $null)


        } // End of: if (needToSearchForDotnetDotExeOnThePath)



        //
        // Ref:
        //
        //    [[
        //      $ type l:\Git\github\dotnet\runtime\global.json
        //      {
        //        ...
        //        "tools": {
        //          "dotnet": "7.0.100-rc.1.22431.12"
        //        },
        //        ...
        //      }
        //    ]]
        //

        $dotnetSdkVersion = $GlobalJson.tools.dotnet



        //
        // <InOriginal>
        //
        // Use dotnet installation specified in DOTNET_INSTALL_DIR if it contains the required SDK
        // version.
        //
        // Otherwise install the dotnet CLI and SDK to repo local .dotnet directory to avoid
        // potential permission issues.
        //
        // </InOriginal>
        //
        ;



        bool canUseAnSdkAlreadyPresentUnderDotnetInstallDir = (

                (-not $globalJsonHasRuntimes)

            -and

                (-not [string]::IsNullOrEmpty($env:DOTNET_INSTALL_DIR))

            -and

                Test-Path(
                    Join-Path $env:DOTNET_INSTALL_DIR "sdk\$dotnetSdkVersion"
                )
        );



        if (canUseAnSdkAlreadyPresentUnderDotnetInstallDir)
        {


            $dotnetRoot = $env:DOTNET_INSTALL_DIR


        }
        else // I.e., if (!canUseAnSdkAlreadyPresentUnderDotnetInstallDir)
        {


            $dotnetRoot =
                Join-Path $RepoRoot '.dotnet'



            bool matchingRepoLocalSdkAlreadyExists = Test-Path(
                Join-Path $dotnetRoot "sdk\$dotnetSdkVersion"
            );



            if (!matchingRepoLocalSdkAlreadyExists)
            {


                if (!$install)
                {


                    Write-PipelineTelemetryError
                        -Category 'InitializeToolset'
                        -Message "Unable to find dotnet with SDK version '$dotnetSdkVersion'"



                    ExitWithExitCode 1


                } // End of: if (!$install)



                InstallDotNetSdk
                    $dotnetRoot
                    $dotnetSdkVersion


            } // End of: if (!matchingRepoLocalSdkAlreadyExists)



            $env:DOTNET_INSTALL_DIR = $dotnetRoot


        } // End of: else // I.e., if (!canUseAnSdkAlreadyPresentUnderDotnetInstallDir)



        //
        // <InOriginal>
        //
        // Creates a temporary file under the toolset dir.
        //
        // The following code block is protecting against concurrent access so that this function
        // can be called in parallel.
        //
        // </InOriginal>
        //

        if ($createSdkLocationFile)
        {


            do
            {


                $sdkCacheFileTemp =
                    Join-Path $ToolsetDir $([System.IO.Path]::GetRandomFileName())


            }
            until (!(Test-Path $sdkCacheFileTemp))



            Set-Content
                -Path $sdkCacheFileTemp
                -Value $dotnetRoot



            try
            {


                Move-Item
                    -Force
                    $sdkCacheFileTemp
                    (Join-Path $ToolsetDir 'sdk.txt')


            }
            catch
            {


                //
                // <InOriginal>
                // Somebody beat us.
                // </InOriginal>
                //

                Remove-Item
                    -Path $sdkCacheFileTemp


            } // End of: catch


        } // End of: if ($createSdkLocationFile)



        //
        // <InOriginal>
        //
        // Add dotnet to PATH.
        //
        // This prevents any bare invocation of dotnet in custom build steps from using anything
        // other than what we've downloaded.
        //
        // It also ensures that VS msbuild will use the downloaded sdk targets.
        //
        // </InOriginal>
        //

        $env:PATH = "$dotnetRoot;$env:PATH"



        //
        // <InOriginal>
        //
        // Make sure that our bootstrapped dotnet cli is available in future steps of the Azure
        // Pipelines build.
        //
        // </InOriginal>
        //
        ;



        Write-PipelinePrependPath
            -Path $dotnetRoot



        Write-PipelineSetVariable
            -Name 'DOTNET_MULTILEVEL_LOOKUP'
            -Value '0'



        Write-PipelineSetVariable
            -Name 'DOTNET_SKIP_FIRST_TIME_EXPERIENCE'
            -Value '1'



        return (
            $global:_DotNetInstallDir = $dotnetRoot
        );


    } // End of: function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile)



    function Retry($downloadBlock, $maxRetries = 5)
    {


        $retries = 1



        while ($true)
        {


            try
            {


                & $downloadBlock



                break


            }
            catch
            {


                Write-PipelineTelemetryError
                    -Category 'InitializeToolset'
                    -Message $_


            } // End of: catch



            ++$retries



            if (!($retries -le $maxRetries))
            {


                Write-PipelineTelemetryError
                    -Category 'InitializeToolset'
                    -Message "Unable to download file in $maxRetries attempts."



                break


            } // End of: if (!($retries -le $maxRetries))



            //
            // <InOriginal>
            // Exponential backoff.
            // </InOriginal>
            //

            $delayInSeconds = (
                    [math]::Pow(2, $retries)
                -
                    1
            )



            Write-Host
                "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."



            Start-Sleep
                -Seconds $delayInSeconds



            continue;


        } // End of: while ($true)



        return;


    } // End of: function Retry($downloadBlock, $maxRetries = 5)



    function GetDotNetInstallScript([string] $dotnetRoot)
    {


        $installScript =
            Join-Path $dotnetRoot 'dotnet-install.ps1'



        if (!(Test-Path $installScript))
        {


            Create-Directory
                $dotnetRoot



            //
            // <InOriginal>
            // Don't display the console progress UI; it's a huge perf hit.
            // </InOriginal>
            //

            $ProgressPreference = 'SilentlyContinue'



            $uri = "https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.ps1"



            Retry(


                {


                    Write-Host
                        "GET $uri"



                    Invoke-WebRequest
                        $uri
                        -OutFile $installScript



                    return;
                }
            )


        } // End of: if (!(Test-Path $installScript))



        return $installScript


    } // End of: function GetDotNetInstallScript([string] $dotnetRoot)



    function InstallDotNetSdk([string] $dotnetRoot, [string] $version, [string] $architecture = '', [switch] $noPath)
    {


        InstallDotNet
            dotnetRoot: $dotnetRoot
            version: $version
            architecture: $architecture
            runtime: ''
            skipNonVersionedFiles: $false
            runtimeSourceFeed: $runtimeSourceFeed
            runtimeSourceFeedKey: $runtimeSourceFeedKey
            noPath: $noPath



        return;


    } // End of: function InstallDotNetSdk([string] $dotnetRoot, [string] $version, [string] $architecture = '', [switch] $noPath)



    function InstallDotNet(
        [string] $dotnetRoot,
        [string] $version,
        [string] $architecture = '',
        [string] $runtime = '',
        [bool] $skipNonVersionedFiles = $false,
        [string] $runtimeSourceFeed = '',
        [string] $runtimeSourceFeedKey = '',
        [switch] $noPath
        )
    {


        $installScript =
            GetDotNetInstallScript $dotnetRoot



        $installParameters = @{
            Version = $version
            InstallDir = $dotnetRoot
        }



        if ($architecture)
        {
            $installParameters.Architecture = $architecture
        }



        if ($runtime)
        {
            $installParameters.Runtime = $runtime
        }



        if ($skipNonVersionedFiles)
        {
            $installParameters.SkipNonVersionedFiles = $skipNonVersionedFiles
        }



        if ($noPath)
        {
            $installParameters.NoPath = $True
        }



        $variations = @()



        $variations += @($installParameters)



        $dotnetBuilds = $installParameters.Clone()



        $dotnetbuilds.AzureFeed = "https://dotnetbuilds.azureedge.net/public"



        $variations += @($dotnetBuilds)



        if ($runtimeSourceFeed)
        {


            $runtimeSource = $installParameters.Clone()



            $runtimeSource.AzureFeed = $runtimeSourceFeed



            if ($runtimeSourceFeedKey)
            {


                $decodedBytes = [System.Convert]::FromBase64String(
                    $runtimeSourceFeedKey
                )



                $decodedString = [System.Text.Encoding]::UTF8.GetString(
                    $decodedBytes
                )



                $runtimeSource.FeedCredential = $decodedString


            } // End of: if ($runtimeSourceFeedKey)



            $variations += @($runtimeSource)


        } // End of: if ($runtimeSourceFeed)



        $installSuccess = $false



        foreach ($variation in $variations)
        {


            $location = (
                ($variation | Get-Member AzureFeed)
                    ?
                            $variation.AzureFeed
                        :
                            "public location"
            );



            Write-Host
                "Attempting to install dotnet from $location."



            try
            {


                & $installScript @variation



                $installSuccess = $true



                break


            }
            catch
            {


                Write-Host "Failed to install dotnet from $location."


            } // End of: catch



            continue;


        } // End of: foreach ($variation in $variations)



        if (-not $installSuccess)
        {


            Write-PipelineTelemetryError
                -Category 'InitializeToolset'
                -Message "Failed to install dotnet from any of the specified locations."



            ExitWithExitCode 1


        } // End of: if (-not $installSuccess)



        return;


    } // End of: function InstallDotNet`8



    //
    // <InOriginal>
    //
    // Locates Visual Studio MSBuild installation.
    //
    // The preference order for MSBuild to use is as follows:
    //
    //    1
    //      MSBuild from an active VS command prompt.
    //
    //    2
    //      MSBuild from a compatible VS installation.
    //
    //    3
    //      MSBuild from the xcopy tool package.
    //
    // Returns full path to msbuild.exe.
    //
    // Throws on failure.
    //
    // </InOriginal>
    //

    function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements = $null)
    {


        if (-not (IsWindowsPlatform))
        {
            throw "Cannot initialize Visual Studio on non-Windows"
        }



        if (Test-Path variable:global:_MSBuildExe)
        {
            return $global:_MSBuildExe
        }



        //
        // <InOriginal>
        // Minimum VS version to require.
        // </InOriginal>
        //
        ;



        $vsMinVersionReqdStr = '16.8'



        $vsMinVersionReqd = [Version]::new(
            $vsMinVersionReqdStr
        )



        //
        // <InOriginal>
        //
        // If the version of msbuild is going to be xcopied, use this version.
        //
        // Version matches a package here:
        //
        //      https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=17.3.1view=overview
        //
        // </InOriginal>
        //

        $defaultXCopyMSBuildVersion = '17.3.1'



        if (!$vsRequirements)
        {


            $vsRequirements = (
                (Get-Member -InputObject $GlobalJson.tools -Name 'vs')
                    ?
                            $GlobalJson.tools.vs
                        :
                            (
                                New-Object
                                    PSObject
                                    -Property @{ version = $vsMinVersionReqdStr }
                            )
            );


        } // End of: if (!$vsRequirements)



        $vsMinVersionStr = (
           !($vsRequirements.version)
                ?
                        $vsMinVersionReqdStr
                    :
                        $vsRequirements.version
        );



        $vsMinVersion = [Version]::new(
            $vsMinVersionStr
        )



        //
        // <InOriginal>
        // Try msbuild command available in the environment.
        // </InOriginal>
        //

        if ($env:VSINSTALLDIR -ne $null)
        {


            $msbuildCmd =
                Get-Command
                    'msbuild.exe'
                    -ErrorAction SilentlyContinue



            if ($msbuildCmd -ne $null)
            {


                //
                // <InOriginal>
                //
                // Workaround for: https://github.com/dotnet/roslyn/issues/35793
                //
                // Due to this issue $msbuildCmd.Version returns 0.0.0.0 for msbuild.exe 16.2+
                //
                // </InOriginal>
                //

                $msbuildVersion = [Version]::new(
                     (
                        Get-Item $msbuildCmd.Path
                     )
                    .VersionInfo
                    .ProductVersion
                    .Split(
                        [char[]]@('-', '+')
                     )
                    [0]
                )



                if (!($msbuildVersion -ge $vsMinVersion))
                {


                    //
                    // <InOriginal>
                    // Report error; the developer environment is initialized with incompatible VS version.
                    // </InOriginal>
                    //

                    throw
                        "Developer Command Prompt for VS $($env:VisualStudioVersion) is not recent enough. "
                        "Please upgrade to $vsMinVersionStr or build from a plain CMD window"


                } // End of: if (!($msbuildVersion -ge $vsMinVersion))



                return (
                    $global:_MSBuildExe = $msbuildCmd.Path
                )


            } // End of: if ($msbuildCmd -ne $null)


        } // End of: if ($env:VSINSTALLDIR -ne $null)



        //
        // <InOriginal>
        // Locate Visual Studio installation or download x-copy msbuild.
        // </InOriginal>
        //
        ;



        $vsInfo =
            LocateVisualStudio $vsRequirements



        if ($vsInfo -ne $null)
        {


            $vsInstallDir = $vsInfo.installationPath



            $vsMajorVersion =
              $vsInfo
                .installationVersion
                .Split('.')
                [0]



            InitializeVisualStudioEnvironmentVariables
                $vsInstallDir
                $vsMajorVersion


        }
        else // I.e., if (!($vsInfo -ne $null))
        {


            bool explicitXcopyMsbuildSettingExists = (
                Get-Member
                    -InputObject $GlobalJson.tools
                    -Name 'xcopy-msbuild'
            )



            if (explicitXcopyMsbuildSettingExists)
            {


                $xcopyMSBuildVersion = $GlobalJson.tools.'xcopy-msbuild'



                $vsMajorVersion =
                  $xcopyMSBuildVersion
                    .Split('.')
                    [0]


            }
            else // I.e., if (!explicitXcopyMsbuildSettingExists)
            {


                //
                // <InOriginal>
                //
                // If the VS version provided in global.json is incompatible (too low) then use the default
                // version for xcopy msbuild download.
                //
                // </InOriginal>
                //

                if ($vsMinVersion -lt $vsMinVersionReqd)
                {


                    Write-Host
                        "Using xcopy-msbuild version of $defaultXCopyMSBuildVersion since VS version $vsMinVersionStr provided in global.json is not compatible"



                    $xcopyMSBuildVersion = $defaultXCopyMSBuildVersion


                }
                else // I.e., if (!($vsMinVersion -lt $vsMinVersionReqd))
                {


                    //
                    // <InOriginal>
                    //
                    // If the VS version IS compatible, look for an xcopy msbuild package with a version
                    // matching VS.
                    //
                    // Notes:
                    //
                    //    .
                    //      If this version does not exist, then an explicit version of xcopy msbuild can be
                    //      specified in global.json.
                    //
                    //    .
                    //      This will be required for pre-release versions of msbuild.
                    //
                    // </InOriginal>
                    //
                    ;



                    $vsMajorVersion = $vsMinVersion.Major



                    $vsMinorVersion = $vsMinVersion.Minor



                    $xcopyMSBuildVersion = "$vsMajorVersion.$vsMinorVersion.0"


                } // End of: else // I.e., if (!($vsMinVersion -lt $vsMinVersionReqd))


            } // End of: else // I.e., if (!explicitXcopyMsbuildSettingExists)



            $vsInstallDir = $null



            if ($xcopyMSBuildVersion.Trim() -ine "none")
            {


                $vsInstallDir =
                    InitializeXCopyMSBuild
                        $xcopyMSBuildVersion
                        $install



                if ($vsInstallDir -eq $null)
                {


                    throw "Could not xcopy msbuild. Please check that package 'RoslynTools.MSBuild @ $xcopyMSBuildVersion' exists on feed 'dotnet-eng'."


                } // End of: if ($vsInstallDir -eq $null)


            } // End of: if ($xcopyMSBuildVersion.Trim() -ine "none")



            if ($vsInstallDir -eq $null)
            {


                throw 'Unable to find Visual Studio that has required version and components installed'


            } // End of: if ($vsInstallDir -eq $null)


        } // End of: else // I.e., if (!($vsInfo -ne $null))



        $msbuildVersionDir = (
           !([int]$vsMajorVersion -lt 16)
                ?
                        "Current"
                    :
                        "$vsMajorVersion.0"
        );



        $local:BinFolder =
            Join-Path $vsInstallDir "MSBuild\$msbuildVersionDir\Bin"



        $local:Prefer64bit = (
           !(Get-Member -InputObject $vsRequirements -Name 'Prefer64bit')
                ?
                        $false
                    :
                        $vsRequirements.Prefer64bit
        );



        bool _64BitIsPreferredAndTheAmd64MsbuildIsPresent = (

                $local:Prefer64bit

            -and

                Test-Path(
                    Join-Path $local:BinFolder "amd64"
                )
        );



        $global:_MSBuildExe = (
            _64BitIsPreferredAndTheAmd64MsbuildIsPresent
                ?
                        (Join-Path $local:BinFolder "amd64\msbuild.exe")
                    :
                        (Join-Path $local:BinFolder "msbuild.exe")
        );



        return $global:_MSBuildExe


    } // End of: function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements = $null)



    function InitializeVisualStudioEnvironmentVariables([string] $vsInstallDir, [string] $vsMajorVersion)
    {


        $env:VSINSTALLDIR = $vsInstallDir



        Set-Item
            "env:VS$($vsMajorVersion)0COMNTOOLS"
            (Join-Path $vsInstallDir "Common7\Tools\")



        $vsSdkInstallDir =
            Join-Path $vsInstallDir "VSSDK\"



        if (Test-Path $vsSdkInstallDir)
        {


            Set-Item
                "env:VSSDK$($vsMajorVersion)0Install"
                $vsSdkInstallDir



            $env:VSSDKInstall = $vsSdkInstallDir


        } // End of: if (Test-Path $vsSdkInstallDir)



        return;


    } // End of: function InitializeVisualStudioEnvironmentVariables([string] $vsInstallDir, [string] $vsMajorVersion)



    function InstallXCopyMSBuild([string]$packageVersion)
    {


        return
            InitializeXCopyMSBuild
                packageVersion: $packageVersion
                install: $true


    } // End of: function InstallXCopyMSBuild([string]$packageVersion)



    function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install)
    {


        $packageName = 'RoslynTools.MSBuild'



        $packageDir = (
            Join-Path $ToolsDir "msbuild\$packageVersion"
        )



        $packagePath = (
            Join-Path $packageDir "$packageName.$packageVersion.nupkg"
        )



        if (!(Test-Path $packageDir))
        {


            if (!$install)
            {
                return $null
            }



            Create-Directory
                $packageDir



            Write-Host
                "Downloading $packageName $packageVersion"



            //
            // <InOriginal>
            // Don't display the console progress UI; it's a huge perf hit.
            // </InOriginal>
            //

            $ProgressPreference = 'SilentlyContinue'



            Retry(


                {


                    Invoke-WebRequest
                        "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/flat2/$packageName/$packageVersion/$packageName.$packageVersion.nupkg"
                        -OutFile $packagePath



                    return;
                }
            )



            Unzip
                $packagePath
                $packageDir


        } // End of: if (!(Test-Path $packageDir))



        return (
            Join-Path $packageDir 'tools'
        );


    } // End of: function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install)



    //
    // <InOriginal>
    //
    // Locates Visual Studio instance that meets the minimal requirements specified by tools.vs
    // object in global.json.
    //
    // The following properties of tools.vs are recognized:
    //
    //    .
    //      "version": "{major}.{minor}"
    //
    //      Two part minimal VS version, e.g. "15.9", "16.0", etc.
    //
    //    .
    //      "components": ["componentId1", "componentId2", ...]
    //
    //       Array of ids of workload components that must be available in the VS instance.
    //       See, e.g., https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-enterprise?view=vs-2017
    //
    // Returns JSON describing the located VS instance (same format as returned by vswhere).
    //
    // Or $null if no instance meeting the requirements is found on the machine.
    //
    // </InOriginal>
    //

    function LocateVisualStudio([object]$vsRequirements = $null)
    {


        if (-not (IsWindowsPlatform))
        {
            throw "Cannot run vswhere on non-Windows platforms."
        }



        $vswhereVersion = (
           !(Get-Member -InputObject $GlobalJson.tools -Name 'vswhere')
                ?
                        '2.5.2'
                    :
                        $GlobalJson.tools.vswhere
        );



        $vsWhereDir =
            Join-Path $ToolsDir "vswhere\$vswhereVersion"



        $vsWhereExe =
            Join-Path $vsWhereDir 'vswhere.exe'



        if (!(Test-Path $vsWhereExe))
        {


            Create-Directory
                $vsWhereDir



            Write-Host
                'Downloading vswhere'



            Retry(


                {


                    Invoke-WebRequest
                        "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe"
                        -OutFile $vswhereExe



                    return;
                }
            )


        } // End of: if (!(Test-Path $vsWhereExe))



        if (!$vsRequirements)
        {


            $vsRequirements = $GlobalJson.tools.vs


        } // End of: if (!$vsRequirements)



        $args = @(
            '-latest',
            '-format', 'json',
            '-requires', 'Microsoft.Component.MSBuild',
            '-products', '*'
        )



        if (!$excludePrereleaseVS)
        {


            $args += '-prerelease'


        } // End of: if (!$excludePrereleaseVS)



        if (Get-Member -InputObject $vsRequirements -Name 'version')
        {


            $args += '-version'

            $args += $vsRequirements.version


        } // End of: if (Get-Member -InputObject $vsRequirements -Name 'version')



        if (Get-Member -InputObject $vsRequirements -Name 'components')
        {


            foreach ($component in $vsRequirements.components)
            {


                $args += '-requires'

                $args += $component

                continue;


            } // End of: foreach ($component in $vsRequirements.components)


        } // End of: if (Get-Member -InputObject $vsRequirements -Name 'components')



        $vsInfo =
                & $vsWhereExe $args
            |
                ConvertFrom-Json



        if ($lastExitCode -ne 0)
        {
            return $null
        }



        //
        // <InOriginal>
        // Use first matching instance.
        // </InOriginal>
        //

        return $vsInfo[0]


    } // End of: function LocateVisualStudio([object]$vsRequirements = $null)



    function InitializeBuildTool()
    {


        if (Test-Path variable:global:_BuildTool)
        {


            //
            // <InOriginal>
            // If the requested msbuild parameters do not match, clear the cached variables.
            // </InOriginal>
            //
            ;



            bool cacheIsIncompatibleWithTheCurrentExcludePreleaseVsSetting = (
                    $global:_BuildTool.Contains('ExcludePrereleaseVS')
                -and
                    ($global:_BuildTool.ExcludePrereleaseVS -ne $excludePrereleaseVS)
            );



            if (!cacheIsIncompatibleWithTheCurrentExcludePreleaseVsSetting)
            {
                return $global:_BuildTool
            }



            Remove-Item variable:global:_BuildTool



            Remove-Item variable:global:_MSBuildExe


        } // End of: if (Test-Path variable:global:_BuildTool)



        if (-not $msbuildEngine)
        {


            $msbuildEngine = GetDefaultMSBuildEngine


        } // End of: if (-not $msbuildEngine)



        //
        // <InOriginal>
        // Initialize dotnet cli if listed in 'tools'.
        // </InOriginal>
        //
        ;



        $dotnetRoot = $null



        //
        // Ref:
        //
        //    [[
        //      $ type l:\Git\github\dotnet\runtime\global.json
        //      {
        //        ...
        //        "tools": {
        //          "dotnet": "7.0.100-rc.1.22431.12"
        //        },
        //        ...
        //      }
        //    ]]
        //

        if (Get-Member -InputObject $GlobalJson.tools -Name 'dotnet')
        {


            $dotnetRoot =
                InitializeDotNetCli
                    install: ($restore ? true : false)


        } // End of: if (Get-Member -InputObject $GlobalJson.tools -Name 'dotnet')



        if ($msbuildEngine -eq 'dotnet')
        {


            if (!$dotnetRoot)
            {


                Write-PipelineTelemetryError
                    -Category 'InitializeToolset'
                    -Message "/global.json must specify 'tools.dotnet'."



                ExitWithExitCode 1


            } // End of: if (!$dotnetRoot)



            $dotnetPath =
                Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')



            //
            // Configure "dotnet msbuild" as the build tool, with "dotnet" specifically coming from the
            // $dotnetRoot established by the call to InitializeDotNetCli above.
            //
            // The "dotnet" installation is commonly found under %DOTNET_INSTALL_DIR% or, if that isn't
            // defined, under "{RepoRoot}\.dotnet".
            //

            $buildTool = @{
                Path = $dotnetPath;
                Command = 'msbuild';
                Tool = 'dotnet';
                Framework = 'net7.0'
            }


        }
        else // I.e., if (!($msbuildEngine -eq 'dotnet'))
        {


            if (!($msbuildEngine -eq "vs"))
            {


                Write-PipelineTelemetryError
                    -Category 'InitializeToolset'
                    -Message "Unexpected value of -msbuildEngine: '$msbuildEngine'."



                ExitWithExitCode 1


            } // End of: if (!($msbuildEngine -eq "vs"))



            try
            {


                $msbuildPath =
                    InitializeVisualStudioMSBuild
                        install: ($restore ? true : false)


            }
            catch
            {


                Write-PipelineTelemetryError
                    -Category 'InitializeToolset'
                    -Message $_



                ExitWithExitCode 1


            } // End of: catch



            //
            // Configure "msbuild" as the build tool, with "msbuild" specifically referring to the
            // msbuild.exe file selected and/or established by the call to InitializeVisualStudioMSBuild
            // above.
            //

            $buildTool = @{
                Path = $msbuildPath;
                Command = "";
                Tool = "vs";
                Framework = "net472";
                ExcludePrereleaseVS = $excludePrereleaseVS
            }


        } // End of: else // I.e., if (!($msbuildEngine -eq 'dotnet'))



        return (
            $global:_BuildTool = $buildTool
        )


    } // End of: function InitializeBuildTool()



    function GetDefaultMSBuildEngine()
    {


        //
        // <InOriginal>
        // Presence of tools.vs indicates the repo needs to build using VS msbuild on Windows.
        // </InOriginal>
        //

        if (Get-Member -InputObject $GlobalJson.tools -Name 'vs')
        {
            return 'vs'
        }



        //
        // Ref:
        //
        //    [[
        //      $ type l:\Git\github\dotnet\runtime\global.json
        //      {
        //        ...
        //        "tools": {
        //          "dotnet": "7.0.100-rc.1.22431.12"
        //        },
        //        ...
        //      }
        //    ]]
        //

        if (Get-Member -InputObject $GlobalJson.tools -Name 'dotnet')
        {
            return 'dotnet'
        }



        Write-PipelineTelemetryError
            -Category 'InitializeToolset'
            -Message "-msbuildEngine must be specified, or /global.json must specify 'tools.dotnet' or 'tools.vs'."



        ExitWithExitCode 1


    } // End of: function GetDefaultMSBuildEngine()



    function GetNuGetPackageCachePath()
    {


        if ($env:NUGET_PACKAGES -eq $null)
        {


            //
            // <InOriginal>
            //
            // Use local cache on CI to ensure deterministic build.
            //
            // Avoid using the http cache as workaround for: https://github.com/NuGet/Home/issues/3116
            //
            // Use global cache in dev builds to avoid cost of downloading packages.
            //
            // For directory normalization, see also: https://github.com/NuGet/Home/issues/7968
            //
            // </InOriginal>
            //

            if ($useGlobalNuGetCache)
            {


                $env:NUGET_PACKAGES =
                    Join-Path $env:UserProfile '.nuget\packages\'


            }
            else // I.e., if (!$useGlobalNuGetCache)
            {


                $env:NUGET_PACKAGES =
                    Join-Path $RepoRoot '.packages\'



                $env:RESTORENOCACHE = $true


            } // End of: else // I.e., if (!$useGlobalNuGetCache)


        } // End of: if ($env:NUGET_PACKAGES -eq $null)



        return $env:NUGET_PACKAGES


    } // End of: function GetNuGetPackageCachePath()



    //
    // <InOriginal>
    // Returns a full path to an Arcade SDK task project file.
    // </InOriginal>
    //

    function GetSdkTaskProject([string]$taskName)
    {


        return
            Join-Path
                (Split-Path (InitializeToolset) -Parent)
                "SdkTasks\$taskName.proj"


    } // End of: function GetSdkTaskProject([string]$taskName)



    function InitializeNativeTools()
    {


        //
        // Ref:
        //
        //    [[
        //      $ findstr /i /c:"native-tools" l:\Git\github\dotnet\runtime\global.json
        //      <no matches>
        //    ]]
        //

        bool nativeToolsAreNeededAndInstallationIsAllowed = (
                (Get-Member -InputObject $GlobalJson -Name "native-tools")
            -And
                -Not (Test-Path variable:DisableNativeToolsetInstalls)
        );



        if (nativeToolsAreNeededAndInstallationIsAllowed)
        {


            $nativeArgs= @{}



            if ($ci)
            {


                $nativeArgs = @{
                    InstallDirectory = "$ToolsDir"
                }


            } // End of: if ($ci)



            if ($env:NativeToolsOnMachine)
            {


                Write-Host
                    "Variable NativeToolsOnMachine detected, enabling native tool path promotion..."



                $nativeArgs += @{ PathPromotion = $true }


            } // End of: if ($env:NativeToolsOnMachine)



            & "$PSScriptRoot/init-tools-native.ps1" @nativeArgs


        } // End of: if (nativeToolsAreNeededAndInstallationIsAllowed)



        return;


    } // End of: function InitializeNativeTools()



    function InitializeToolset()
    {


        if (Test-Path variable:global:_ToolsetBuildProj)
        {
            return $global:_ToolsetBuildProj
        }



        $nugetCache = GetNuGetPackageCachePath



        //
        // Ref:
        //
        //    [[
        //      $ type l:\Git\github\dotnet\runtime\global.json
        //      {
        //        ...
        //        "msbuild-sdks": {
        //          "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.22554.2",
        //          ...
        //        }
        //      }
        //    ]]
        //

        $toolsetVersion =
          $GlobalJson
            .'msbuild-sdks'
            .'Microsoft.DotNet.Arcade.Sdk'



        $toolsetLocationFile =
            Join-Path $ToolsetDir "$toolsetVersion.txt"



        if (Test-Path $toolsetLocationFile)
        {


            $path =
                Get-Content
                    $toolsetLocationFile
                    -TotalCount 1



            if (Test-Path $path)
            {


                return (
                    $global:_ToolsetBuildProj = $path
                )


            } // End of: if (Test-Path $path)


        } // End of: if (Test-Path $toolsetLocationFile)



        if (-not $restore)
        {


            Write-PipelineTelemetryError
                -Category 'InitializeToolset'
                -Message "Toolset version $toolsetVersion has not been restored."



            ExitWithExitCode 1


        } // End of: if (-not $restore)



        //
        // Bind to the runner tool associated with the configured msbuild engine (generally
        // selected by GetDefaultMSBuildEngine).
        //
        // The tool will be "msbuild" if the "vs" engine has been selected, with "msbuild"
        // specifically referring to the msbuild.exe file selected and/or established during a call
        // to InitializeVisualStudioMSBuild.
        //
        // The tool will be "dotnet msbuild" if the "dotnet" engine has been selected, with
        // "dotnet" specifically coming from the $dotnetRoot established during a call call to
        // InitializeDotNetCli.  This "dotnet" installation is commonly found under
        // %DOTNET_INSTALL_DIR% or, if that isn't defined, under "{RepoRoot}\.dotnet".
        //

        $buildTool = InitializeBuildTool



        $proj =
            Join-Path $ToolsetDir 'restore.proj'



        $bl = (
           !($binaryLog)
                ?
                        ''
                    :
                        ( '/bl:' + (Join-Path $LogDir 'ToolsetRestore.binlog') )
        );



        //
        // Fill the "{ToolsetDir}\restore.proj" file with the following content:
        //
        //    [[
        //      <Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>
        //    ]]
        //
        // Notes:
        //
        //    .
        //      By default, the *.proj file will be located at "{RepoRoot}\toolset\restore.proj" given
        //      the was $ToolsetDir is initialized at the end of this script.
        //
        //    .
        //      The {ToolsetDir} may be an empty directory at this point (it is created by the top-level
        //      directives at the end of this script, but is not populated with any files).
        //

            '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>'
        |
            Set-Content $proj



        //
        // Defer to callee code in the MSBuild-Core function which will
        //
        //    .
        //      take the msbuild runner tool located by InitializeBuildTool (as detailed above)
        //
        //    .
        //      and run it against the single-line
        //
        //        [[
        //          <Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>
        //        ]]
        //
        //      file that was written to "{ToolsetDir}\restore.proj" above
        //
        //    .
        //      with this invocation specifically targeting just the __WriteToolsetLocation target.
        //
        //
        // As shown below, this target seems to be defined in {src\Microsoft.DotNet.Arcade.Sdk\sdk\Sdk.targets}
        // in the dotnet/arcade repo (with the other two hits representing the Windows and Unix
        // copies, respectively, that are presumably the "original source" of the tools.* files
        // that are checked in to the dotnet/runtime repo and are being listed here):
        //
        //    [[
        //      l:\Git\github\dotnet\arcade $ findstr /psrn __WriteToolsetLocation *
        //      eng\common\tools.ps1:682:  MSBuild-Core $proj $bl /t:__WriteToolsetLocation /clp:ErrorsOnly`;NoSummary /p:__ToolsetLocationOutputFile=$toolsetLocationFile
        //      eng\common\tools.sh:381:  MSBuild-Core "$proj" $bl /t:__WriteToolsetLocation /clp:ErrorsOnly\;NoSummary /p:__ToolsetLocationOutputFile="$toolset_location_file"
        //      src\Microsoft.DotNet.Arcade.Sdk\sdk\Sdk.targets:22:  <Target Name="__WriteToolsetLocation" Outputs="$(__ToolsetLocationOutputFile)" Condition="'$(__ToolsetLocationOutputFile)' != ''">
        //    ]]
        //
        // Notes:
        //
        //    .
        //      For more information, see the {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\sdk\Sdk.targets}
        //      file listing elsewhere in this file.
        //
        //    .
        //      As shown in the listing, the __WriteToolsetLocation target generally fills the
        //      $toolsetLocationFile with the path to the {tools\Build.proj} file within the
        //      Microsoft.DotNet.Arcade.Sdk package.
        //
        //    .
        //      In the dotnet\arcade repo, this file seems to be found at:
        //          {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
        //
        //    .
        //      There seems to be an expectation that this msbuild command will pull in the specific
        //      "$toolsetVersion" that was probed above; if this in fact happens, my guess is that it
        //      occurs to the global.json "msbuild-sdks" setting probed above somehow exerting a
        //      "steering" effect on the logic that msbuild uses to select the Microsoft.DotNet.Arcade.Sdk
        //      version to use.
        //

        MSBuild-Core
            $proj
            $bl
            /t:__WriteToolsetLocation
            /clp:ErrorsOnly`;NoSummary
            /p:__ToolsetLocationOutputFile=$toolsetLocationFile



        $path =
            Get-Content
                $toolsetLocationFile
                -Encoding UTF8
                -TotalCount 1



        if (!(Test-Path $path))
        {
            throw "Invalid toolset path: $path"
        }



        //
        // As described above, this path generally refers to the {tools\Build.proj} file within the
        // Microsoft.DotNet.Arcade.Sdk package, and therefore refers to a copy of the file found at
        // {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}.
        //

        return (
            $global:_ToolsetBuildProj = $path
        )


    } // End of: function InitializeToolset()



    function ExitWithExitCode([int] $exitCode)
    {


        if ($ci -and $prepareMachine)
        {


            Stop-Processes


        } // End of: if ($ci -and $prepareMachine)



        exit $exitCode


    } // End of: function ExitWithExitCode([int] $exitCode)



    //
    // <InOriginal>
    //
    // Check if $LASTEXITCODE is a nonzero exit code (NZEC).
    //
    // If so, print a Azure Pipeline error for diagnostics, then exit the script with the
    // $LASTEXITCODE.
    //
    // </InOriginal>
    //

    function Exit-IfNZEC([string] $category = "General")
    {


        Write-Host
            "Exit code $LASTEXITCODE"



        if ($LASTEXITCODE -ne 0)
        {


            $message = "Last command failed with exit code $LASTEXITCODE."



            Write-PipelineTelemetryError
                -Force
                -Category $category
                -Message $message



            ExitWithExitCode $LASTEXITCODE


        } // End of: if ($LASTEXITCODE -ne 0)



        return;


    } // End of: function Exit-IfNZEC([string] $category = "General")



    function Stop-Processes()
    {


        Write-Host
            'Killing running build processes...'



        foreach ($processName in $processesToStopOnExit)
        {


                Get-Process
                    -Name $processName
                    -ErrorAction SilentlyContinue
            |
                Stop-Process



            continue;


        } // End of: foreach ($processName in $processesToStopOnExit)



        return;


    } // End of: function Stop-Processes()



    //
    // <InOriginal>
    //
    // Executes msbuild (or 'dotnet msbuild') with arguments passed to the function.
    //
    // The arguments are automatically quoted.
    //
    // Terminates the script if the build fails.
    //
    // </InOriginal>
    //

    function MSBuild()
    {


        if ($pipelinesLog)
        {


            $buildTool = InitializeBuildTool



            if ($ci)
            {


                if ($buildTool.Tool -eq 'dotnet')
                {


                    $env:NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS = 20



                    $env:NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS = 20



                    Write-PipelineSetVariable
                        -Name 'NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS'
                        -Value '20'



                    Write-PipelineSetVariable
                        -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS'
                        -Value '20'


                } // End of: if ($buildTool.Tool -eq 'dotnet')


            } // End of: if ($ci)



            Enable-Nuget-EnhancedRetry



            $toolsetBuildProject = InitializeToolset



            $basePath =
                Split-Path -parent $toolsetBuildProject



            //
            // <InOriginal>
            //
            // New scripts need to work with old packages, so we need to look for the old
            // names/versions.
            //
            // </InOriginal>
            //

            $possiblePaths = @(
                (Join-Path $basePath (Join-Path $buildTool.Framework 'Microsoft.DotNet.ArcadeLogging.dll')),
                (Join-Path $basePath (Join-Path $buildTool.Framework 'Microsoft.DotNet.Arcade.Sdk.dll')),
                (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.ArcadeLogging.dll')),
                (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
                (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.ArcadeLogging.dll')),
                (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
            )



            $selectedPath = $null



            foreach ($path in $possiblePaths)
            {


                if (Test-Path $path -PathType Leaf)
                {


                    $selectedPath = $path



                    break


                } // End of: if (Test-Path $path -PathType Leaf)



                continue;


            } // End of: foreach ($path in $possiblePaths)



            if (-not $selectedPath)
            {


                Write-PipelineTelemetryError
                    -Category 'Build'
                    -Message 'Unable to find arcade sdk logger assembly.'



                ExitWithExitCode 1


            } // End of: if (-not $selectedPath)



            $args += "/logger:$selectedPath"


        } // End of: if ($pipelinesLog)



        MSBuild-Core
            @args



        return;


    } // End of: function MSBuild()



    //
    // <InOriginal>
    //
    // Executes msbuild (or 'dotnet msbuild') with arguments passed to the function.
    //
    // The arguments are automatically quoted.
    //
    // Terminates the script if the build fails.
    //
    // </InOriginal>
    //

    function MSBuild-Core()
    {


        if ($ci)
        {


            if (!$binaryLog)
            {


                if (!$excludeCIBinarylog)
                {


                    Write-PipelineTelemetryError
                        -Category 'Build'
                        -Message 'Binary log must be enabled in CI build, or explicitly opted-out from with the -excludeCIBinarylog switch.'



                    ExitWithExitCode 1


                } // End of: if (!$excludeCIBinarylog)


            } // End of: if (!$binaryLog)



            if ($nodeReuse)
            {


                Write-PipelineTelemetryError
                    -Category 'Build'
                    -Message 'Node reuse must be disabled in CI build.'



                ExitWithExitCode 1


            } // End of: if ($nodeReuse)


        } // End of: if ($ci)



        Enable-Nuget-EnhancedRetry



        //
        // Bind to the runner tool associated with the configured msbuild engine (generally
        // selected by GetDefaultMSBuildEngine).
        //
        // The tool will be "msbuild" if the "vs" engine has been selected, with "msbuild"
        // specifically referring to the msbuild.exe file selected and/or established during a call
        // to InitializeVisualStudioMSBuild.
        //
        // The tool will be "dotnet msbuild" if the "dotnet" engine has been selected, with
        // "dotnet" specifically coming from the $dotnetRoot established during a call call to
        // InitializeDotNetCli.  This "dotnet" installation is commonly found under
        // %DOTNET_INSTALL_DIR% or, if that isn't defined, under "{RepoRoot}\.dotnet".
        //

        $buildTool = InitializeBuildTool



        $cmdArgs = "
            $($buildTool.Command)
                /m
                /nologo
                /clp:Summary
                /v:$verbosity
                /nr:$nodeReuse
                /p:ContinuousIntegrationBuild=$ci
        "


        $cmdArgs += (
            $warnAsError
                ?
                        ' /warnaserror /p:TreatWarningsAsErrors=true'
                    :
                        ' /p:TreatWarningsAsErrors=false'
        );



        //
        // Walk through the function arguments supplied by the caller and append each of them to
        // the "cmdArgs" set.
        //

        foreach ($arg in $args)
        {



            if (($arg -ne $null) -and ($arg.Trim() -ne ""))
            {


                if ($arg.EndsWith('\'))
                {


                    $arg = ($arg + "\")


                } // End of: if ($arg.EndsWith('\'))



                $cmdArgs += " `"$arg`""


            } // End of: if (($arg -ne $null) -and ($arg.Trim() -ne ""))



            continue;


        } // End of: foreach ($arg in $args)



        $env:ARCADE_BUILD_TOOL_COMMAND = "$($buildTool.Path) $cmdArgs"



        $exitCode =
            Exec-Process
                $buildTool.Path
                $cmdArgs



        if ($exitCode -ne 0)
        {


            //
            // <InOriginal>
            //
            // We should not Write-PipelineTaskError here because that message shows up in the build
            // summary.
            //
            // The build already logged an error, that's the reason it failed.
            //
            // Producing an error here only adds noise.
            //
            // </InOriginal>
            //

            Write-Host
                "Build failed with exit code $exitCode. Check errors above."
                -ForegroundColor Red



            $buildLog =
                GetMSBuildBinaryLogCommandLineArgument
                    $args



            if ($buildLog -ne $null)
            {


                Write-Host
                    "See log: $buildLog"
                    -ForegroundColor DarkGray


            } // End of: if ($buildLog -ne $null)



            if (!$ci)
            {


                ExitWithExitCode $exitCode


            }
            else // I.e., if ($ci)
            {


                Write-PipelineSetResult
                    -Result "Failed"
                    -Message "msbuild execution failed."



                //
                // <InOriginal>
                //
                // Exiting with an exit code causes the azure pipelines task to log yet another "noise"
                // error.
                //
                // The above Write-PipelineSetResult will cause the task to be marked as failure without
                // adding yet another error.
                //
                // </InOriginal>
                //

                ExitWithExitCode 0


            } // End of: else // I.e., if ($ci)


        } // End of: if ($exitCode -ne 0)



        return;


    } // End of: function MSBuild-Core()



    function GetMSBuildBinaryLogCommandLineArgument($arguments)
    {


        foreach ($argument in $arguments)
        {


            if ($argument -ne $null)
            {


                $arg = $argument.Trim()



                if ($arg.StartsWith('/bl:', "OrdinalIgnoreCase"))
                {
                    return $arg.Substring('/bl:'.Length)
                }



                if ($arg.StartsWith('/binaryLogger:', 'OrdinalIgnoreCase'))
                {
                    return $arg.Substring('/binaryLogger:'.Length)
                }


            } // End of: if ($argument -ne $null)



            continue;


        } // End of: foreach ($argument in $arguments)



        return $null


    } // End of: function GetMSBuildBinaryLogCommandLineArgument($arguments)



    function GetExecutableFileName($baseName)
    {


        return (
            IsWindowsPlatform
                ?
                        "$baseName.exe"
                    :
                        $baseName
        );


    } // End of: function GetExecutableFileName($baseName)



    function IsWindowsPlatform()
    {


        return (
            ([environment]::OSVersion.Platform -eq [PlatformID]::Win32NT) ? true : false
        );


    } // End of: function IsWindowsPlatform()



    function Get-Darc($version)
    {


        $darcPath = "$TempDir\darc\$(New-Guid)"



        if ($version -eq $null)
        {


                & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath
            |
                Out-Host


        }
        else // I.e., if (!($version -eq $null))
        {


                & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath -darcVersion $version
            |
                Out-Host


        } // End of: else // I.e., if (!($version -eq $null))



        return "$darcPath\darc.exe"


    } // End of: function Get-Darc($version)



    . $PSScriptRoot\pipeline-logging-functions.ps1



    $RepoRoot =
        Resolve-Path (Join-Path $PSScriptRoot '..\..\')



    $EngRoot =
        Resolve-Path (Join-Path $PSScriptRoot '..')



    $ArtifactsDir =
        Join-Path $RepoRoot 'artifacts'



    $ToolsetDir =
        Join-Path $ArtifactsDir 'toolset'



    $ToolsDir =
        Join-Path $RepoRoot '.tools'



    $LogDir =
        Join-Path (Join-Path $ArtifactsDir 'log') $configuration



    $TempDir =
        Join-Path (Join-Path $ArtifactsDir 'tmp') $configuration



    $GlobalJson = (
            Get-Content
                -Raw
                -Path (Join-Path $RepoRoot 'global.json')
        |
            ConvertFrom-Json
    );



    //
    // <InOriginal>
    // True if global.json contains a "runtimes" section.
    // </InOriginal>
    //
    // Ref:
    //
    //    [[
    //      $ findstr /i /c:"runtimes" l:\Git\github\dotnet\runtime\global.json
    //      <no matches>
    //    ]]
    //

    $globalJsonHasRuntimes = (
        ($GlobalJson.tools.PSObject.Properties.Name -Match 'runtimes') ? true : false
    );



    //
    // Create, e.g., dotnet\runtime\toolset.
    //

    Create-Directory
        $ToolsetDir



    Create-Directory
        $TempDir



    Create-Directory
        $LogDir



    Write-PipelineSetVariable
        -Name 'Artifacts'
        -Value $ArtifactsDir



    Write-PipelineSetVariable
        -Name 'Artifacts.Toolset'
        -Value $ToolsetDir



    Write-PipelineSetVariable
        -Name 'Artifacts.Log'
        -Value $LogDir



    Write-PipelineSetVariable
        -Name 'TEMP'
        -Value $TempDir



    Write-PipelineSetVariable
        -Name 'TMP'
        -Value $TempDir



    //
    // <InOriginal>
    //
    // Import custom tools configuration, if present in the repo.
    //
    // Notes:
    //
    //    .
    //      Import in global scope so that the script set top-level variables without qualification.
    //
    // </InOriginal>
    //

    if (!$disableConfigureToolsetImport)
    {


        $configureToolsetScript =
            Join-Path $EngRoot 'configure-toolset.ps1'



        if (Test-Path $configureToolsetScript)
        {


            . $configureToolsetScript



            bool needToHardFailIfConfigureToolsetFails = (
                    (Test-Path variable:failOnConfigureToolsetError)
                -And
                    $failOnConfigureToolsetError
            );



            if (needToHardFailIfConfigureToolsetFails)
            {


                bool configureToolsetFailed = (
                        (Test-Path variable:LastExitCode)
                    -And
                        ($LastExitCode -ne 0)
                );



                if (configureToolsetFailed)
                {


                    Write-PipelineTelemetryError
                        -Category 'Build'
                        -Message 'configure-toolset.ps1 returned a non-zero exit code'



                    ExitWithExitCode $LastExitCode


                } // End of: if (configureToolsetFailed)


            } // End of: if (needToHardFailIfConfigureToolsetFails)


        } // End of: if (Test-Path $configureToolsetScript)


    } // End of: if (!$disableConfigureToolsetImport)



    //
    // <InOriginal>
    //
    // If $ci flag is set, turn on (and log that we did) special environment variables for
    // improved Nuget client retry logic.
    //
    // </InOriginal>
    //

    function Enable-Nuget-EnhancedRetry()
    {


        if ($ci)
        {


            Write-Host
                "Setting NUGET enhanced retry environment variables"



            $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'



            $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6



            $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000



            Write-PipelineSetVariable
                -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY'
                -Value 'true'



            Write-PipelineSetVariable
                -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT'
                -Value '6'



            Write-PipelineSetVariable
                -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS'
                -Value '1000'


        } // End of: if ($ci)



        return;


    } // End of: function Enable-Nuget-EnhancedRetry()
}






{l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\sdk\Sdk.targets}


<?xml version="1.0" encoding="utf-8"?>
<Project>



    //
    // <InOriginal>
    //
    // If a project specifies ExcludeFromSourceBuild=true during a source build, suppress all
    // targets and emulate a no-op (empty common targets like Restore, Build, Pack, etc).
    //
    // It's also possible to set ExcludeFromBuild prior to importing the Sdk.targets to skip
    // building as desired in non-source build scenarios.
    //
    // This might be done to avoid building tests in certain product build scenarios.
    //
    // </InOriginal>
    //

    <PropertyGroup>
        <_SuppressAllTargets>false</_SuppressAllTargets>
        <_SuppressAllTargets Condition="'$(DotNetBuildFromSource)' == 'true' and '$(ExcludeFromSourceBuild)' == 'true'">true</_SuppressAllTargets>
        <_SuppressAllTargets Condition="'$(ExcludeFromBuild)' == 'true'">true</_SuppressAllTargets>
    </PropertyGroup>



    //
    // <InOriginal>
    //
    // Output the location of the Build.proj so that the build driver can find where it was
    // restored.
    //
    // Ideally we would have msbuild API to do that for an SDK: https://github.com/Microsoft/msbuild/issues/2992
    //
    // </InOriginal>
    //

    <Target Name="__WriteToolsetLocation"
        Outputs="$(__ToolsetLocationOutputFile)"
        Condition="'$(__ToolsetLocationOutputFile)' != ''"
        >



        //
        // Relative to the dotnet/arcade root, this file resides at:
        //
        //      sdk\Sdk.targets
        //
        // As a result, adding "..\tools\Build.proj" binds to the file that resides at the
        // following relative path:
        //
        //      tools\Build.proj
        //

        <WriteLinesToFile
            File="$(__ToolsetLocationOutputFile)"
            Lines="$([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)..\tools\Build.proj'))"
            Overwrite="true"
        />



        <ItemGroup>
            <FileWrites Include="$(__ToolsetLocationOutputFile)" />
        </ItemGroup>


    </Target> // End of: <Target Name="__WriteToolsetLocation"



    <Import Project="..\tools\Imports.targets"
        Condition="!$(_SuppressSdkImports) and !$(_SuppressAllTargets)"
    />



    <Import Project="..\tools\Empty.targets"
        Condition="!$(_SuppressSdkImports) and $(_SuppressAllTargets)"
    />


</Project>







{l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}


    //
    // During build.cmd, this file is reached via the following sequence:
    //
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //

<Project DefaultTargets="Execute">



    //
    // <InOriginal>
    //
    //      Required parameters:
    //
    //          RepoRoot
    //
    //              Repository root.
    //
    //          Projects
    //
    //              List of projects to build.
    //
    //              Semicolon separated, may include globs.
    //
    //      Optional parameters:
    //
    //          Configuration
    //
    //              Build configuration: "Debug", "Release", etc.
    //
    //          DotNetBuildFromSource
    //
    //              Building the entire stack from source with no external dependencies.
    //
    //          DotNetOutputBlobFeedDir
    //
    //              Directory to publish Source Build assets to (packages, symbol packages, installers,
    //              etc).
    //
    //          DotNetPublishUsingPipelines
    //
    //              Publish assets to Build Asset Registry.
    //
    //          DotNetSymbolServerTokenMsdl
    //
    //              Personal access token for MSDL symbol server.
    //
    //              Available from variable group DotNet-Symbol-Server-Pats.
    //
    //          DotNetSymbolServerTokenSymWeb
    //
    //              Personal access token for SymWeb symbol server.
    //
    //              Available from variable group DotNet-Symbol-Server-Pats.
    //
    //          DotNetSymbolExpirationInDays
    //
    //              Symbol expiration time in days (defaults to 10 years).
    //
    //          DotNetSignType
    //
    //              Specifies the signing type: 'real' (default), 'test'.
    //
    //          DotNetRuntimeSourceFeed
    //
    //              Storage account to lookup for the .Net runtime files.
    //
    //          DotNetRuntimeSourceFeedKey
    //
    //              In case the storage account to fetch the .Net runtime files are private this should
    //              contain a SAS token.
    //
    //          ContinuousIntegrationBuild
    //
    //              "true" when building on a CI server (PR build or official build).
    //
    //          Restore
    //
    //              "true" to restore toolset and solution.
    //
    //          Build
    //
    //              "true" to build solution.
    //
    //          Rebuild
    //
    //              "true" to rebuild solution.
    //
    //          Deploy
    //
    //              "true" to deploy assets (e.g., VSIXes).
    //
    //          Test
    //
    //              "true" to run tests
    //
    //          IntegrationTest
    //
    //              "true" to run integration tests.
    //
    //          PerformanceTest
    //
    //              "true" to run performance tests.
    //
    //          Pack
    //
    //              "true" to build NuGet packages and VS insertion manifests.
    //
    //          Sign
    //
    //              "true" to sign built binaries.
    //
    //          Publish
    //
    //              "true" to publish artifacts (e.g., symbols).
    //
    // </InOriginal>
    //
    ;



    <PropertyGroup>
        <_OriginalProjectsValue>$(Projects)</_OriginalProjectsValue>
    </PropertyGroup>



    <ItemDefinitionGroup>
        <ProjectToBuild>
            <RestoreInParallel>true</RestoreInParallel>
            <BuildInParallel>true</BuildInParallel>
        </ProjectToBuild>
    </ItemDefinitionGroup>



    //
    // Establish a large variety of paths defined relative to the repo root.
    //

    <Import Project="RepoLayout.props"/>



    <Import Project="SourceBuild/SourceBuildArcadeBuild.targets"
        Condition="'$(ArcadeBuildFromSource)' == 'true'"
    />



    //
    // <InOriginal>
    // Allow for repo specific Build properties such as the list of Projects to build.
    // </InOriginal>
    //
    // Ref:
    //
    //    [[
    //      $ type l:\Git\github\dotnet\runtime\eng\Build.props
    //      <Project>
    //        <PropertyGroup>
    //          <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
    //          <GenerateRestoreUseStaticGraphEvaluationBinlog>true</GenerateRestoreUseStaticGraphEvaluationBinlog>
    //        </PropertyGroup>
    //        <ItemGroup>
    //          <ProjectToBuild Include="$(RepoRoot)Build.proj" />
    //        </ItemGroup>
    //      </Project>
    //    ]]
    //

    <Import Project="$(RepositoryEngineeringDir)Build.props"
        Condition="Exists('$(RepositoryEngineeringDir)Build.props')"
    />



    <PropertyGroup>


        <_ProjectsPropertyWasUpdatedInBuildProps Condition="'$(_OriginalProjectsValue)' != '$(Projects)'">
            true
        </_ProjectsPropertyWasUpdatedInBuildProps>


    </PropertyGroup>



    <ItemGroup Condition="'$(Projects)' != ''">



        //
        // <InOriginal>
        // Copy the original list so we can log diagnostics later.
        // </InOriginal>
        //

        <_OriginalProjectToBuild Include="@(ProjectToBuild)" />



        //
        // <InOriginal>
        // Setting 'Projects' overrides the ProjectToBuild list.
        // </InOriginal>
        //

        <ProjectToBuild Remove="@(ProjectToBuild)" />

        <ProjectToBuild Include="$(Projects)" />


    </ItemGroup> // End of: <ItemGroup Condition="'$(Projects)' != ''">



    //
    // <InOriginal>
    //
    // If Projects is unspecified and ProjectToBuild was not set via Build.props, fallback to
    // building .sln files in the repo root.
    //
    // </InOriginal>
    //

    <ItemGroup Condition="'@(ProjectToBuild)' == ''">


        <ProjectToBuild Include="$(RepoRoot)*.sln" />


    </ItemGroup> // End of: <ItemGroup Condition="'@(ProjectToBuild)' == ''">



    <PropertyGroup>



        <_DotNetOutputBlobFeedDir>
            $(DotNetOutputBlobFeedDir)
        </_DotNetOutputBlobFeedDir>



        <_DotNetOutputBlobFeedDir
            Condition="
                    '$(_DotNetOutputBlobFeedDir)' != ''
                and
                   !HasTrailingSlash('$(_DotNetOutputBlobFeedDir)')
            "
        >

            $(_DotNetOutputBlobFeedDir)\

        </_DotNetOutputBlobFeedDir>


    </PropertyGroup>



    <Target Name="Execute">



        <Error
            Text="No projects were found to build. Either the 'Projects' property or 'ProjectToBuild' item group must be specified."
            Condition="'@(ProjectToBuild)' == ''"
        />



        <Error
            Text="Property 'RepoRoot' must be specified"
            Condition="'$(RepoRoot)' == ''"
        />



        <Error
            Text="File 'global.json' must exist in directory specified by RepoRoot: '$(RepoRoot)'"
            Condition="
                    '$(RepoRoot)' != ''
                and
                   !Exists('$(RepoRoot)global.json')
            "
        />



        <PropertyGroup>



            //
            // <InOriginal>
            //
            // 'IsRunningFromVisualStudio' may be true even when running msbuild.exe from command line.
            //
            // This generally means that MSBuild is from a Visual Studio installation and therefore we
            // need to find NuGet.targets in a different location.
            //
            // </InOriginal>
            //
            ;



            <_NuGetRestoreTargets Condition="Exists('$(MSBuildToolsPath)\NuGet.targets')" >
                $(MSBuildToolsPath)\NuGet.targets
            </_NuGetRestoreTargets>



            <_NuGetRestoreTargets
                Condition="
                        '$([MSBuild]::IsRunningFromVisualStudio())' == 'true'
                    And
                        Exists('$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets')
                "
            >

                $(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets

            </_NuGetRestoreTargets>



            //
            // <InOriginal>
            // If `DotNetPublishUsingPipelines` is not set we default it to false.
            // </InOriginal>
            //

            <DotNetPublishUsingPipelines Condition="'$(DotNetPublishUsingPipelines)' == ''">
                false
            </DotNetPublishUsingPipelines>



            //
            // <InOriginal>
            //
            // If DotNetPublishUsingPipelines is set we don't publish symbols during the build stage,
            // only in the Maestro post-build stages.
            //
            // If DotNetPublishUsingPipelines is NOT set then we publish symbols during the build
            // stage.
            //
            // </InOriginal>
            //
            ;



            <PublishToSymbolServer>
                true
            </PublishToSymbolServer>



            <PublishToSymbolServer Condition="'$(DotNetPublishUsingPipelines)' == 'true'">
                false
            </PublishToSymbolServer>


        </PropertyGroup>



        <ItemGroup>



            <_SolutionBuildTargets
                Include="Rebuild"
                Condition="'$(Rebuild)' == 'true'"
            />



            <_SolutionBuildTargets
                Include="Build"
                Condition="
                        '$(Build)' == 'true'
                    and
                        '$(Rebuild)' != 'true'
                "
            />



            //
            // <InOriginal>
            // Deploy target is set up to chain after Build so that F5 in VS works.
            // </InOriginal>
            //

            <_SolutionBuildTargets
                Include="Test"
                Condition="'$(Test)' == 'true'"
            />



            //
            // <InOriginal>
            //
            // Pack before running integration and performance tests so that these tests can test
            // packages produced by the repo.
            //
            // </InOriginal>
            //
            ;



            <_SolutionBuildTargets
                Include="Pack"
                Condition="'$(Pack)' == 'true'"
            />



            <_SolutionBuildTargets
                Include="IntegrationTest"
                Condition="'$(IntegrationTest)' == 'true'"
            />



            <_SolutionBuildTargets
                Include="PerformanceTest"
                Condition="'$(PerformanceTest)' == 'true'"
            />


        </ItemGroup>



        <PropertyGroup>


            <_RemoveProps>
                Projects;
                Restore;
                Deploy;
                Sign;
                Publish;
                NETCORE_ENGINEERING_TELEMETRY;
                @(_SolutionBuildTargets)
            </_RemoveProps>


        </PropertyGroup>



        <ItemGroup>



            <_CommonProps
                Include="Configuration=$(Configuration)"
            />



            <_CommonProps
                Include="ContinuousIntegrationBuild=$(ContinuousIntegrationBuild)"
            />



            <_CommonProps
                Include="RepoRoot=$(RepoRoot)"
            />



            <_CommonProps
                Include="VersionsPropsPath=$(VersionsPropsPath)"
            />



            //
            // <InOriginal>
            //
            // When building from source we suppress restore for projects that set
            // ExcludeFromSourceBuild=true.
            //
            // NuGet Restore task reports a warning for such projects, which we suppress here.
            //
            // </InOriginal>
            //

            <_CommonProps
                Include="DisableWarnForInvalidRestoreProjects=true"
                Condition="'$(DotNetBuildFromSource)' == 'true'"
            />



            //
            // <InOriginal>
            //
            // C++ projects expect VCTargetsPath property to be set.
            //
            // MSBuild generates this property to solution metaproject when solution is built directly,
            // but doesn't do so when the solution is built using MSBuild task.
            //
            // </InOriginal>
            //

            <_CommonProps
                Condition="'$(MSBuildRuntimeType)' != 'Core'"
                Include="
                    VCTargetsPath=$(
                        [MSBuild]::ValueOrDefault(
                            '$(VCTargetsPath)',
                            '$([MSBuild]::GetVsInstallRoot())\Common7\IDE\VC\VCTargets\'
                        )
                    )
                "
            />


        </ItemGroup>



        <ItemGroup Condition="'$(Restore)' == 'true'">



            <_RestoreToolsProps
                Include="@(_CommonProps)"
            />



            <_RestoreToolsProps
                Include="BaseIntermediateOutputPath=$(ArtifactsToolsetDir)Common"
            />



            <_RestoreToolsProps
                Include="ExcludeRestorePackageImports=true"
            />



            <_RestoreToolsProps
                Include="_NuGetRestoreTargets=$(_NuGetRestoreTargets)"
            />



            //
            // <InOriginal>
            //
            // Used in the SDK (Tools.proj) to control whether Build.Tasks.Feed will be restored or
            // not.
            //
            // </InOriginal>
            //

            <_RestoreToolsProps
                Include="Publish=$(Publish)"
            />



            //
            // <InOriginal>
            //
            // Used in the SDK (Tools.proj) to control whether SymbolUploader.Build.Task will be
            // restored or not.
            //
            // </InOriginal>
            //

            <_RestoreToolsProps
                Include="PublishToSymbolServer=$(PublishToSymbolServer)"
            />



            //
            // <InOriginal>
            // Forward this property because we can't assume it will be available globally.
            // </InOriginal>
            //

            <_RestoreToolsProps
                Include="DotNetPublishUsingPipelines=$(DotNetPublishUsingPipelines)"
            />


        </ItemGroup> // End of: <ItemGroup Condition="'$(Restore)' == 'true'">



        //
        // <InOriginal>
        //
        // Builds from the 'internal' project, and only those, can download the .net Runtime from a
        // private location.
        //
        // </InOriginal>
        //

        <ItemGroup Condition="'$(SYSTEM_TEAMPROJECT)' == 'internal'">



            <_RestoreToolsProps
                Include="DotNetRuntimeSourceFeed=$(DotNetRuntimeSourceFeed)"
            />



            <_RestoreToolsProps
                Include="DotNetRuntimeSourceFeedKey=$(DotNetRuntimeSourceFeedKey)"
            />


        </ItemGroup> // End of: <ItemGroup Condition="'$(SYSTEM_TEAMPROJECT)' == 'internal'">



        <ItemGroup>



            <_PublishProps
                Include="@(_CommonProps)"
            />



            <_PublishProps
                Include="DotNetOutputBlobFeedDir=$(_DotNetOutputBlobFeedDir)"
                Condition="'$(_DotNetOutputBlobFeedDir)' != ''"
            />



            //
            // <InOriginal>
            // Used in a few places in the stack to decide if publishing was enabled or not.
            // </InOriginal>
            //

            <_PublishProps
                Include="Publish=$(Publish)"
            />



            //
            // <InOriginal>
            //
            // Used in the SDK (Publish.proj) to control whether in-build symbol publishing should be
            // performed.
            //
            // </InOriginal>
            //

            <_PublishProps
                Include="PublishToSymbolServer=$(PublishToSymbolServer)"
            />



            //
            // <InOriginal>
            // Forward this property because we can't assume it will be available globally.
            // </InOriginal>
            //

            <_PublishProps
                Include="DotNetPublishUsingPipelines=$(DotNetPublishUsingPipelines)"
            />


        </ItemGroup>



        <ItemGroup>



            <_SolutionBuildProps
                Include="@(_CommonProps)"
            />



            <_SolutionBuildProps
                Include="__DeployProjectOutput=$(Deploy)"
                Condition="'$(Deploy)' != ''"
            />


        </ItemGroup>



        //
        // <InOriginal>
        // Restore built-in tools.
        // </InOriginal>
        //

        <MSBuild
            Condition="'$(Restore)' == 'true'"
            Projects="Tools.proj"
            Targets="Restore"
            Properties="@(_RestoreToolsProps);_NETCORE_ENGINEERING_TELEMETRY=Restore"
        />



        //
        // <InOriginal>
        //
        // Restore solutions and projects.
        //
        // Run solution restore separately from the other targets, in a different build phase.
        //
        // Since restore brings in new .props and .targets files we need to rerun evaluation.
        //
        // Workarounds:
        //
        //    .
        //      Invoke restore using NuGet.targets directly (see https://github.com/NuGet/Home/issues/7648).
        //
        //      This avoids duplicate calls to RestoreTask and race conditions on writing restore
        //      results to disk.
        //
        //    .
        //      msbuild caches the metaproject for the solution (see https://github.com/Microsoft/msbuild/issues/1695).
        //
        //      We invalidate the cache by changing the value of __BuildPhase property.
        //
        // </InOriginal>
        //
        ;



        <ItemGroup>



            <_SolutionRestoreProps
                Include="@(_SolutionBuildProps)"
            />



            <_SolutionRestoreProps
                Include="__BuildPhase=SolutionRestore"
            />



            <_SolutionRestoreProps
                Include="_NETCORE_ENGINEERING_TELEMETRY=Restore"
            />



            <_SolutionRestoreProps
                Include="MSBuildRestoreSessionId=$([System.Guid]::NewGuid())"
            />



            <_SolutionRestoreProps
                Include="RestoreUseStaticGraphEvaluation=$(RestoreUseStaticGraphEvaluation)"
            />


        </ItemGroup>



        <PropertyGroup>


            //
            // <InOriginal>
            // This can be set to false as an optimization for repos that don't use NuGet.
            // </InOriginal>
            //

            <RestoreUsingNuGetTargets Condition="'$(RestoreUsingNuGetTargets)' == ''">
                true
            </RestoreUsingNuGetTargets>


        </PropertyGroup>



        //
        // <InOriginal>
        //
        // Detect which projects support restoring with NuGet targets.
        //
        // As a perf optimization, the Properties list here should match exactly with the
        // properties passed to the "Restore" target a few lines below.
        //
        // This helps MSBuild cache the result of _IsProjectRestoreSupported.
        //
        // No need to call into the nuget internal target when restoring using the new msbuild
        // static graph APIs (RestoreUseStaticGraphEvaluation=true).
        //
        // </InOriginal>
        //

        <MSBuild
            Condition="
                    '$(RestoreUsingNuGetTargets)' != 'false'
                and
                    '%(ProjectToBuild.Extension)' != '.sln'
                and
                    '%(ProjectToBuild.Extension)' != '.slnf'
                and
                    '$(RestoreUseStaticGraphEvaluation)' != 'true'
                and
                    '$(Restore)' == 'true'
            "

            Projects="@(ProjectToBuild)"
            Targets="_IsProjectRestoreSupported"
            SkipNonexistentTargets="true"
            Properties="@(_SolutionRestoreProps)"
            RemoveProperties="$(_RemoveProps)"
            BuildInParallel="true"
        >

            <Output
                TaskParameter="TargetOutputs"
                ItemName="_ProjectToRestoreWithNuGet"
            />

        </MSBuild>



        <PropertyGroup>


            //
            // <InOriginal>
            // Normalize paths to avoid false warnings by NuGet about missing project references.
            // </InOriginal>
            //

            <_ProjectToRestoreWithNuGetList>
                @(_ProjectToRestoreWithNuGet->'%(FullPath)')
            </_ProjectToRestoreWithNuGetList>


        </PropertyGroup>



        <ItemGroup>


            <_ProjectToRestore
                Include="$(_NuGetRestoreTargets)"
                Condition="
                        '$(_ProjectToRestoreWithNuGetList)' != ''
                    and
                        '$(RestoreUsingNuGetTargets)' != 'false'
                "
            >


                <AdditionalProperties>
                    RestoreGraphProjectInput=$(_ProjectToRestoreWithNuGetList)
                </AdditionalProperties>



                <RestoreInParallel>
                    true
                </RestoreInParallel>


            </_ProjectToRestore>



            //
            // <InOriginal>
            // Invoke the 'Restore' target on solutions and projects which do not support NuGet.
            // </InOriginal>
            //

            <_ProjectToRestore
                Include="@(ProjectToBuild)"
                Exclude="@(_ProjectToRestoreWithNuGet)"
            />


        </ItemGroup>



        //
        // <InOriginal>
        // Enable binlog generation during static graph restore evaluation.
        // </InOriginal>
        //

        <ItemGroup Condition="'$(GenerateRestoreUseStaticGraphEvaluationBinlog)' == 'true'">


            <_ProjectToRestore>


                <AdditionalProperties>
                    RESTORE_TASK_BINLOG_PARAMETERS=$(ArtifactsLogDir)Restore-%(Filename)%(Extension).binlog
                </AdditionalProperties>


            </_ProjectToRestore>


        </ItemGroup> // End of: <ItemGroup Condition="'$(GenerateRestoreUseStaticGraphEvaluationBinlog)' == 'true'">



        <MSBuild
            Condition="'$(Restore)' == 'true'"
            Projects="@(_ProjectToRestore)"
            Targets="Restore"
            SkipNonexistentTargets="true"
            Properties="@(_SolutionRestoreProps)"
            RemoveProperties="$(_RemoveProps);TreatWarningsAsErrors"
            BuildInParallel="%(_ProjectToRestore.RestoreInParallel)"
        />



        //
        // <InOriginal>
        // Build solution.
        // </InOriginal>
        //

        <MSBuild
            Condition="'@(_SolutionBuildTargets)' != ''"
            Projects="@(ProjectToBuild)"
            Targets="@(_SolutionBuildTargets)"
            Properties="@(_SolutionBuildProps);__BuildPhase=SolutionBuild;_NETCORE_ENGINEERING_TELEMETRY=Build"
            RemoveProperties="$(_RemoveProps)"
            BuildInParallel="%(ProjectToBuild.BuildInParallel)"
        />



        <MSBuild
            Condition="'@(_SolutionBuildTargets)' != ''"
            Projects="AfterSolutionBuild.proj"
            Targets="@(_SolutionBuildTargets)"
            Properties="@(_CommonProps);_NETCORE_ENGINEERING_TELEMETRY=Build"
        />



        //
        // <InOriginal>
        // Sign artifacts.
        // </InOriginal>
        //

        <MSBuild
            Condition="'$(Sign)' == 'true'"
            Targets="Sign"
            Projects="Sign.proj"
            Properties="@(_CommonProps)"
        />



        <MSBuild
            Condition="'@(_SolutionBuildTargets)' != ''"
            Projects="AfterSigning.proj"
            Targets="@(_SolutionBuildTargets)"
            Properties="@(_CommonProps);_NETCORE_ENGINEERING_TELEMETRY=Sign"
        />



        //
        // <InOriginal>
        //
        // Perform post-source-build tasks.
        //
        // Validate source-build requirements, such as the prebuilt usage baseline, and generate
        // the source-build intermediate nupkg.
        //
        // </InOriginal>
        //

        <MSBuild
            Condition="'$(ArcadeBuildFromSource)' == 'true'"
            Projects="SourceBuild\AfterSourceBuild.proj"
            Properties="@(_CommonProps);_NETCORE_ENGINEERING_TELEMETRY=AfterSourceBuild"
        />



        //
        // <InOriginal>
        // Publish artifacts.
        // </InOriginal>
        //

        <MSBuild
            Condition="
                    '$(Publish)' == 'true'
                and
                    '$(DotNetBuildFromSource)' != 'true'
            "

            Projects="Publish.proj"
            Targets="Publish"
            Properties="@(_PublishProps);_NETCORE_ENGINEERING_TELEMETRY=Publish"
        />


    </Target> // End of: <Target Name="Execute">


</Project>






{l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\RepoLayout.props}


<?xml version="1.0" encoding="utf-8"?>
<Project>



    //
    // <InOriginal>
    // Properties describing the layout of the repo.
    // </InOriginal>
    //
    ;



    <PropertyGroup>
        <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
        <Platform Condition="'$(Platform)' == ''">AnyCPU</Platform>
        <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
    </PropertyGroup>



    //
    // <InOriginal>
    //
    // Respect environment variable for the NuGet Packages Root if set; otherwise, use the
    // current default location.
    //
    // </InOriginal>
    //

    <PropertyGroup>



        <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' != ''">
            $([MSBuild]::NormalizeDirectory('$(NuGetPackageRoot)'))
        </NuGetPackageRoot>



        <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(NUGET_PACKAGES)' != ''">
            $([MSBuild]::NormalizeDirectory('$(NUGET_PACKAGES)'))
        </NuGetPackageRoot>



        <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(OS)' == 'Windows_NT'">
            $([MSBuild]::NormalizeDirectory('$(UserProfile)', '.nuget', 'packages'))
        </NuGetPackageRoot>



        <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(OS)' != 'Windows_NT'">
            $([MSBuild]::NormalizeDirectory('$(HOME)', '.nuget', 'packages'))
        </NuGetPackageRoot>


    </PropertyGroup>



    //
    // If RepoRoot isn't set, search up from the directory where this *.proj file resides
    // looking for the nearest parent directory which contains a file named global.json.
    //

    <PropertyGroup>


        <RepoRoot Condition="'$(RepoRoot)' == ''">
            $(
                [MSBuild]::NormalizeDirectory(
                    '
                        $(
                            [MSBuild]::GetDirectoryNameOfFileAbove(
                                $(MSBuildProjectDirectory),
                                'global.json'
                            )
                        )
                    '
                )
            )
        </RepoRoot>


    </PropertyGroup>



    <PropertyGroup Condition="'$(DotNetTool)' == ''">



        //
        // <InOriginal>
        //
        // Respect environment variable for the .NET install directory if set; otherwise, use the
        // repo default location.
        //
        // </InOriginal>
        //
        ;



        <DotNetRoot Condition="'$(DOTNET_INSTALL_DIR)' != ''">
            $(DOTNET_INSTALL_DIR)
        </DotNetRoot>



        <DotNetRoot Condition="'$(DotNetRoot)' != ''">
            $([MSBuild]::NormalizeDirectory('$(DotNetRoot)'))
        </DotNetRoot>



        <DotNetRoot Condition="'$(DotNetRoot)' == ''">
            $([MSBuild]::NormalizeDirectory('$(RepoRoot)', '.dotnet'))
        </DotNetRoot>



        //
        // <InOriginal>
        // Let the exec task find dotnet on PATH.
        // </InOriginal>
        //

        <DotNetRoot
            Condition="!Exists($(DotNetRoot))"
        />



        <DotNetTool Condition="'$(OS)' == 'Windows_NT'">
            $(DotNetRoot)dotnet.exe
        </DotNetTool>



        <DotNetTool Condition="'$(OS)' != 'Windows_NT'">
            $(DotNetRoot)dotnet
        </DotNetTool>


    </PropertyGroup> // End of: <PropertyGroup Condition="'$(DotNetTool)' == ''">



    <PropertyGroup Condition="'$(MonoTool)' == ''">


        <MonoTool>mono</MonoTool>


    </PropertyGroup> // End of: <PropertyGroup Condition="'$(MonoTool)' == ''">



    <PropertyGroup>


        <RepositoryEngineeringDir>
            $([MSBuild]::NormalizeDirectory('$(RepoRoot)', 'eng'))
        </RepositoryEngineeringDir>



        <RepositoryToolsDir>
            $([MSBuild]::NormalizeDirectory('$(RepoRoot)', '.tools'))
        </RepositoryToolsDir>



        <VersionsPropsPath>
            $(RepositoryEngineeringDir)Versions.props
        </VersionsPropsPath>



        <ArtifactsDir Condition="'$(ArtifactsDir)' == ''">
            $([MSBuild]::NormalizeDirectory('$(RepoRoot)', 'artifacts'))
        </ArtifactsDir>



        <ArtifactsToolsetDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'toolset'))
        </ArtifactsToolsetDir>



        <ArtifactsObjDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'obj'))
        </ArtifactsObjDir>



        <ArtifactsBinDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'bin'))
        </ArtifactsBinDir>



        <ArtifactsLogDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'log', '$(Configuration)'))
        </ArtifactsLogDir>



        <ArtifactsLogNgenDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsLogDir)', 'ngen'))
        </ArtifactsLogNgenDir>



        <ArtifactsTmpDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'tmp', '$(Configuration)'))
        </ArtifactsTmpDir>



        <ArtifactsTestResultsDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'TestResults', '$(Configuration)'))
        </ArtifactsTestResultsDir>



        <ArtifactsSymStoreDirectory>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'SymStore', '$(Configuration)'))
        </ArtifactsSymStoreDirectory>



        <ArtifactsPackagesDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'packages', '$(Configuration)'))
        </ArtifactsPackagesDir>



        <ArtifactsShippingPackagesDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsPackagesDir)', 'Shipping'))
        </ArtifactsShippingPackagesDir>



        <ArtifactsNonShippingPackagesDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsPackagesDir)', 'NonShipping'))
        </ArtifactsNonShippingPackagesDir>



        <VisualStudioSetupOutputPath>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'VSSetup', '$(Configuration)'))
        </VisualStudioSetupOutputPath>



        <VisualStudioSetupInsertionPath>
            $([MSBuild]::NormalizeDirectory('$(VisualStudioSetupOutputPath)', 'Insertion'))
        </VisualStudioSetupInsertionPath>



        <VisualStudioSetupIntermediateOutputPath>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'VSSetup.obj', '$(Configuration)'))
        </VisualStudioSetupIntermediateOutputPath>



        <VisualStudioBuildPackagesDir>
            $([MSBuild]::NormalizeDirectory('$(VisualStudioSetupOutputPath)', 'DevDivPackages'))
        </VisualStudioBuildPackagesDir>


    </PropertyGroup>


</Project>





{l:\Git\github\dotnet\runtime\Build.proj}


    //
    // During build.cmd, this file is reached via the following sequence:
    //
    //      {l:\Git\github\dotnet\runtime\Build.proj}
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //
    //
    // Notes:
    //
    //    .
    //      Microsoft.Build.Traversal is implemented and and described at:
    //          l:\Git\github\Microsoft\MSBuildSdks\src\Traversal\...
    //          https://github.com/microsoft/MSBuildSdks
    //
    //    .
    //      Overall, Microsoft.Build.Traversal appears to just be a system for "fanning out" the
    //      build across all of the projects referenced by the ProjectReference collection.
    //

<Project Sdk="Microsoft.Build.Traversal">



    <ItemGroup>



        //
        // <InOriginal>
        // Subsets are already imported by Directory.Build.props.
        // </InOriginal>
        //
        // See #NATURE_OF_DIRECTORY_DOT_BUILD_FILES.
        //
        // As mentioned in the product comment above, processing along the following import stack
        //
        //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
        //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
        //      ...
        //
        // has already loaded the ProjectToBuild item group with a rich description of the nature
        // and order of the full universe of project files that need to be built in order to carry
        // out all of the actions associated with the requested build subsets.
        //
        // Since this file is a Microsoft.Build.Traversal SDK project, including the ProjectToBuild
        // set into the ProjectReference set creates a situation where the traversal machinery will
        // "fan out" the build across all of the listed project files.
        //
        // Notes:
        //
        //    .
        //      Due to the CustomAfterTraversalTargets setting applied in Directory.Build.props, the
        //      traversal is subjec to the customization applied in the following file:
        //      {l:\Git\github\dotnet\runtime\eng\TraversalSdk.AfterTargets.targets}
        //

        <ProjectReference
            Include="@(ProjectToBuild)"
        />



        //
        // <InOriginal>
        // Only include tasks.proj during restore and build incrementally via a target.
        // </InOriginal>
        //

        <ProjectReference
            Include="$(RepoTasksDir)tasks.proj"
            Condition="'$(MSBuildRestoreSessionId)' != ''"
        />


    </ItemGroup>



    //
    // Print a descriptive error and fail the build if the user-supplied Subset property refers
    // to any subsets that lie outside of the SubsetName "allow list" that was created along
    // the following stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
    //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
    //      ...
    //

    <Import Project="$(RepositoryEngineeringDir)SubsetValidation.targets" />



    //
    // <InOriginal>
    // Upfront restore hooks.
    // </InOriginal>
    //
    ;



    <Import Project="$(RepositoryEngineeringDir)restore\docs.targets" />



    <Import Project="$(RepositoryEngineeringDir)restore\optimizationData.targets"
        Condition="'$(DotNetBuildFromSource)' != 'true'"
    />



    <Target
        Name="BuildLocalTasks"
        BeforeTargets="Build"
    >


        <MSBuild
            Projects="$(RepoTasksDir)tasks.proj"
            Targets="BuildIncrementally"
        />


    </Target> // End of: <Target Name="BuildLocalTasks"


</Project>






{l:\Git\github\dotnet\runtime\Directory.Build.props}


    //
    // Notes:
    //
    //    .
    //      See the the {l:\Git\github\dotnet\runtime\Build.proj} file listing and
    //      #NATURE_OF_DIRECTORY_DOT_BUILD_FILES for information on how build.cmd operations end up
    //      calling through into this project file.
    //

<Project>



    <PropertyGroup>



        //
        // <InOriginal>
        //
        // For non-SDK projects that import this file and then import Microsoft.Common.props, tell
        // Microsoft.Common.props not to import Directory.Build.props again.
        //

        <ImportDirectoryBuildProps>
            false
        </ImportDirectoryBuildProps>



        //
        // <InOriginal>
        //
        // Used to determine if we should build some packages only once across multiple official
        // build legs.
        //
        // For offline builds we still set OfficialBuildId but we need to build all the packages
        // for a single leg only, so we also take DotNetBuildFromSource into account.
        //
        // </InOriginal>
        //

        <BuildingAnOfficialBuildLeg
            Condition="
                    '$(BuildingAnOfficialBuildLeg)' == ''
                and
                    '$(OfficialBuildId)' != ''
                and
                    '$(DotNetBuildFromSource)' != 'true'
            "
        >

            true

        </BuildingAnOfficialBuildLeg>


    </PropertyGroup>



    <PropertyGroup Label="CalculateTargetOS">



        <_hostOS>
            Linux
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('OSX'))">
            OSX
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('FREEBSD'))">
            FreeBSD
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('NETBSD'))">
            NetBSD
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('ILLUMOS'))">
            illumos
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('SOLARIS'))">
            Solaris
        </_hostOS>



        <_hostOS Condition="$([MSBuild]::IsOSPlatform('WINDOWS'))">
            windows
        </_hostOS>



        <HostOS>
            $(_hostOS)
        </HostOS>



        <TargetOS
            Condition="
                    '$(TargetOS)' == ''
                and
                    '$(RuntimeIdentifier)' == 'browser-wasm'
            "
        >

            browser

        </TargetOS>



        <TargetOS Condition="'$(TargetOS)' == ''">
            $(_hostOS)
        </TargetOS>



        <TargetsMobile
            Condition="
                    '$(TargetOS)' == 'iOS'
                or
                    '$(TargetOS)' == 'iOSSimulator'
                or
                    '$(TargetOS)' == 'MacCatalyst'
                or
                    '$(TargetOS)' == 'tvOS'
                or
                    '$(TargetOS)' == 'tvOSSimulator'
                or
                    '$(TargetOS)' == 'Android'
                or
                    '$(TargetOS)' == 'Browser'
            "
        >

            true

        </TargetsMobile>



        <TargetsAppleMobile
            Condition="
                    '$(TargetOS)' == 'iOS'
                or
                    '$(TargetOS)' == 'iOSSimulator'
                or
                    '$(TargetOS)' == 'MacCatalyst'
                or
                    '$(TargetOS)' == 'tvOS'
                or
                    '$(TargetOS)' == 'tvOSSimulator'
            "
        >

            true

        </TargetsAppleMobile>


    </PropertyGroup> // End of: <PropertyGroup Label="CalculateTargetOS">



    //
    // <InOriginal>
    // Platform property is required by RepoLayout.props in Arcade SDK.
    // </InOriginal>
    //

    <PropertyGroup Label="CalculateArch">



        <_hostArch>
            $(
                  [System.Runtime.InteropServices.RuntimeInformation]
                ::ProcessArchitecture
                 .ToString()
                 .ToLowerInvariant
            )
        </_hostArch>



        <BuildArchitecture Condition="'$(BuildArchitecture)' == ''">
            $(_hostArch)
        </BuildArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'arm'">
            arm
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'armv6'">
            armv6
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'armel'">
            armel
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'arm64'">
            arm64
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'loongarch64'">
            loongarch64
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 's390x'">
            s390x
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(_hostArch)' == 'ppc64le'">
            ppc64le
        </TargetArchitecture>



        <TargetArchitecture
            Condition="

                    '$(TargetArchitecture)' == ''

                and

                    (
                            '$(TargetOS)' == 'Browser'
                        or
                            '$(RuntimeIdentifier)' == 'browser-wasm'
                    )
            "
        >

            wasm

        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == '' and '$(TargetsMobile)' == 'true'">
            x64
        </TargetArchitecture>



        <TargetArchitecture Condition="'$(TargetArchitecture)' == ''">
            x64
        </TargetArchitecture>



        <Platform
            Condition="
                    '$(Platform)' == ''
                and
                    '$(InferPlatformFromTargetArchitecture)' == 'true'
            "
        >

            $(TargetArchitecture)

        </Platform>


    </PropertyGroup> // End of: <PropertyGroup Label="CalculateArch">



    //
    // <InOriginal>
    // Import the Arcade SDK.
    // </InOriginal>
    //

    <Import Project="Sdk.props"
        Sdk="Microsoft.DotNet.Arcade.Sdk"
    />



    //
    // <InOriginal>
    // The TFMs to build and test against.
    // </InOriginal>
    //

    <PropertyGroup>



        <NetCoreAppCurrentVersion>
            7.0
        </NetCoreAppCurrentVersion>



        <NetCoreAppCurrentIdentifier>
            .NETCoreApp
        </NetCoreAppCurrentIdentifier>



        <NetCoreAppCurrentTargetFrameworkMoniker>
            $(NetCoreAppCurrentIdentifier),Version=v$(NetCoreAppCurrentVersion)
        </NetCoreAppCurrentTargetFrameworkMoniker>



        <MicrosoftNetCoreAppFrameworkName>
            Microsoft.NETCore.App
        </MicrosoftNetCoreAppFrameworkName>



        <NetCoreAppCurrentBrandName>
            .NET $(NetCoreAppCurrentVersion)
        </NetCoreAppCurrentBrandName>



        <NetCoreAppCurrent>
            net$(NetCoreAppCurrentVersion)
        </NetCoreAppCurrent>



        <NetCoreAppMinimum>
            net6.0
        </NetCoreAppMinimum>



        <NetCoreAppMinimum Condition="'$(DotNetBuildFromSource)' == 'true'">
            $(NetCoreAppCurrent)
        </NetCoreAppMinimum>



        <NetCoreAppToolCurrentVersion>
            7.0
        </NetCoreAppToolCurrentVersion>



        <NetCoreAppToolCurrent>
            net$(NetCoreAppToolCurrentVersion)
        </NetCoreAppToolCurrent>



        <NetCoreAppCurrentToolTargetFrameworkMoniker>
            $(NetCoreAppCurrentIdentifier),Version=v$(NetCoreAppToolCurrentVersion)
        </NetCoreAppCurrentToolTargetFrameworkMoniker>



        <NetCoreAppLatestStableVersion>
            6.0
        </NetCoreAppLatestStableVersion>



        <NetCoreAppLatestStablePackageBaselineVersion>
            $(NetCoreAppLatestStableVersion).0
        </NetCoreAppLatestStablePackageBaselineVersion>



        <NetCoreAppLatestStable>
            net$(NetCoreAppLatestStableVersion)
        </NetCoreAppLatestStable>



        <AspNetCoreAppCurrentVersion>
            7.0
        </AspNetCoreAppCurrentVersion>



        <AspNetCoreAppCurrent>
            net$(AspNetCoreAppCurrentVersion)
        </AspNetCoreAppCurrent>



        <NetFrameworkMinimum>
            net462
        </NetFrameworkMinimum>



        <NetFrameworkToolCurrent>
            net472
        </NetFrameworkToolCurrent>



        //
        // <InOriginal>
        // Don't build for NETFramework during source-build.
        // </InOriginal>
        //

        <NetFrameworkToolCurrent Condition="'$(DotNetBuildFromSource)' == 'true'">
        </NetFrameworkToolCurrent>



        <TargetFrameworkForNETFrameworkTasks>
            $(NetFrameworkToolCurrent)
        </TargetFrameworkForNETFrameworkTasks>



        //
        // <InOriginal>
        // Don't build for NETFramework during source-build.
        // </InOriginal>
        //

        <TargetFrameworkForNETFrameworkTasks Condition="'$(DotNetBuildFromSource)' == 'true'">
        </TargetFrameworkForNETFrameworkTasks>



        <TargetFrameworkForNETCoreTasks>
            $(NetCoreAppToolCurrent)
        </TargetFrameworkForNETCoreTasks>


    </PropertyGroup>



    <PropertyGroup>



        <LibrariesProjectRoot>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'libraries'))
        </LibrariesProjectRoot>



        <CoreClrProjectRoot>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'coreclr'))
        </CoreClrProjectRoot>



        <MonoProjectRoot>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'mono'))
        </MonoProjectRoot>



        <InstallerProjectRoot>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'installer'))
        </InstallerProjectRoot>



        <WorkloadsProjectRoot>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'workloads'))
        </WorkloadsProjectRoot>



        <SharedNativeRoot>
            $([MSBuild]::NormalizeDirectory('$(RepoRoot)', 'src', 'native'))
        </SharedNativeRoot>



        <RepoToolsLocalDir>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'tools-local'))
        </RepoToolsLocalDir>



        <RepoTasksDir>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'src', 'tasks'))
        </RepoTasksDir>



        <IbcOptimizationDataDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'ibc'))
        </IbcOptimizationDataDir>



        <MibcOptimizationDataDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'mibc'))
        </MibcOptimizationDataDir>



        <XmlDocDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'docs'))
        </XmlDocDir>



        <XmlDocFileRoot>
            $(
                [MSBuild]::NormalizeDirectory(
                    '$(NuGetPackageRoot)',
                    'microsoft.private.intellisense',
                    '$(MicrosoftPrivateIntellisenseVersion)',
                    'IntellisenseFiles',
                    'net'
                )
            )
        </XmlDocFileRoot>



        <DocsDir>
            $([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', 'docs'))
        </DocsDir>



        <ManPagesDir>
            $([MSBuild]::NormalizeDirectory('$(DocsDir)', 'manpages'))
        </ManPagesDir>



        <AppleAppBuilderDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'AppleAppBuilder', 'Debug', '$(NetCoreAppToolCurrent)'))
        </AppleAppBuilderDir>



        <AndroidAppBuilderDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'AndroidAppBuilder', 'Debug', '$(NetCoreAppToolCurrent)', 'publish'))
        </AndroidAppBuilderDir>



        <WasmAppBuilderDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'WasmAppBuilder', 'Debug', '$(NetCoreAppToolCurrent)'))
        </WasmAppBuilderDir>



        <WasmBuildTasksDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'WasmBuildTasks', 'Debug', '$(NetCoreAppToolCurrent)', 'publish'))
        </WasmBuildTasksDir>



        <WorkloadBuildTasksDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'WorkloadBuildTasks', 'Debug', '$(NetCoreAppToolCurrent)'))
        </WorkloadBuildTasksDir>



        <MonoAOTCompilerDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'MonoAOTCompiler', 'Debug', '$(NetCoreAppToolCurrent)'))
        </MonoAOTCompilerDir>



        <MonoTargetsTasksDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'MonoTargetsTasks', 'Debug', '$(NetCoreAppToolCurrent)'))
        </MonoTargetsTasksDir>



        <TestExclusionListTasksDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'TestExclusionListTasks', 'Debug', '$(NetCoreAppToolCurrent)'))
        </TestExclusionListTasksDir>



        <InstallerTasksAssemblyPath Condition="'$(MSBuildRuntimeType)' == 'Core'">
            $([MSBuild]::NormalizePath('$(ArtifactsBinDir)', 'installer.tasks', 'Debug', '$(NetCoreAppToolCurrent)', 'installer.tasks.dll'))
        </InstallerTasksAssemblyPath>



        <InstallerTasksAssemblyPath Condition="'$(MSBuildRuntimeType)' != 'Core'">
            $([MSBuild]::NormalizePath('$(ArtifactsBinDir)', 'installer.tasks', 'Debug', '$(NetFrameworkToolCurrent)', 'installer.tasks.dll'))
        </InstallerTasksAssemblyPath>



        <Crossgen2SdkOverridePropsPath Condition="'$(MSBuildRuntimeType)' == 'Core'">
            $([MSBuild]::NormalizePath('$(ArtifactsBinDir)', 'Crossgen2Tasks', 'Debug', '$(NetCoreAppToolCurrent)', 'Microsoft.NET.CrossGen.props'))
        </Crossgen2SdkOverridePropsPath>



        <Crossgen2SdkOverrideTargetsPath Condition="'$(MSBuildRuntimeType)' == 'Core'">
            $([MSBuild]::NormalizePath('$(ArtifactsBinDir)', 'Crossgen2Tasks', 'Debug', '$(NetCoreAppToolCurrent)', 'Microsoft.NET.CrossGen.targets'))
        </Crossgen2SdkOverrideTargetsPath>



        <AppleAppBuilderTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(AppleAppBuilderDir)', 'AppleAppBuilder.dll'))
        </AppleAppBuilderTasksAssemblyPath>



        <AndroidAppBuilderTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(AndroidAppBuilderDir)', 'AndroidAppBuilder.dll'))
        </AndroidAppBuilderTasksAssemblyPath>



        <WasmAppBuilderTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(WasmAppBuilderDir)', 'WasmAppBuilder.dll'))
        </WasmAppBuilderTasksAssemblyPath>



        <WasmBuildTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(WasmBuildTasksDir)', 'WasmBuildTasks.dll'))
        </WasmBuildTasksAssemblyPath>



        <WasmAppHostDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'WasmAppHost', 'wasm', '$(Configuration)'))
        </WasmAppHostDir>



        <WorkloadBuildTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(WorkloadBuildTasksDir)', 'WorkloadBuildTasks.dll'))
        </WorkloadBuildTasksAssemblyPath>



        <MonoAOTCompilerTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(MonoAOTCompilerDir)', 'MonoAOTCompiler.dll'))
        </MonoAOTCompilerTasksAssemblyPath>



        <MonoTargetsTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(MonoTargetsTasksDir)', 'MonoTargetsTasks.dll'))
        </MonoTargetsTasksAssemblyPath>



        <TestExclusionListTasksAssemblyPath>
            $([MSBuild]::NormalizePath('$(TestExclusionListTasksDir)', 'TestExclusionListTasks.dll'))
        </TestExclusionListTasksAssemblyPath>



        <CoreCLRToolPath>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'coreclr', '$(TargetOS).$(TargetArchitecture).$(Configuration)'))
        </CoreCLRToolPath>



        <ILAsmToolPath
            Condition="
                    '$(DotNetBuildFromSource)' == 'true'
                or
                    '$(BuildArchitecture)' == 's390x'
                or
                    '$(BuildArchitecture)' == 'ppc64le'
            "
        >

            $(CoreCLRToolPath)

        </ILAsmToolPath>


    </PropertyGroup>



    <PropertyGroup Label="CalculateConfiguration">



        //
        // <InOriginal>
        //
        // The RuntimeConfiguration property allows to pass in/specify a configuration that applies
        // to both CoreCLR and Mono.
        //
        // </InOriginal>
        //
        ;



        <RuntimeConfiguration Condition="'$(RuntimeConfiguration)' == ''">
            $(Configuration)
        </RuntimeConfiguration>



        //
        // I think this directive is a no-op since the directive above will set
        // <RuntimeConfiguration> to non-empty, and therefore disable the condition below, in any
        // case where $(Configuration) is "Debug" or "Release.
        //

        <RuntimeConfiguration
            Condition="

                    '$(RuntimeConfiguration)' == ''

                and

                    (
                            '$(Configuration)' == 'Debug'
                        or
                            '$(Configuration)' == 'Release'
                    )
            "
        >

            $(Configuration)

        </RuntimeConfiguration>



        <RuntimeConfiguration Condition="'$(RuntimeConfiguration)' == ''">
            Debug
        </RuntimeConfiguration>



        <CoreCLRConfiguration Condition="'$(CoreCLRConfiguration)' == ''">
            $(RuntimeConfiguration)
        </CoreCLRConfiguration>



        <MonoConfiguration
            Condition="
                    '$(MonoConfiguration)' == ''
                and
                    '$(RuntimeConfiguration.ToLower())' != 'checked'
            "
        >

            $(RuntimeConfiguration)

        </MonoConfiguration>



        //
        // <InOriginal>
        // There's no checked configuration on Mono.
        // </InOriginal>
        //

        <MonoConfiguration
            Condition="
                    '$(MonoConfiguration)' == ''
                and
                    '$(RuntimeConfiguration.ToLower())' == 'checked'
            "
        >

            Debug

        </MonoConfiguration>



        <LibrariesConfiguration Condition="'$(LibrariesConfiguration)' == ''">
            $(Configuration)
        </LibrariesConfiguration>



        <HostConfiguration Condition="'$(HostConfiguration)' == ''">
            $(Configuration)
        </HostConfiguration>


    </PropertyGroup> // End of: <PropertyGroup Label="CalculateConfiguration">



    <PropertyGroup Label="CalculateOS">



        //
        // <InOriginal>
        // Default to portable build if not explicitly set.
        // </InOriginal>
        //

        <PortableBuild Condition="'$(PortableBuild)' == ''">
            true
        </PortableBuild>



        <_parseDistroRid>
            $(__DistroRid)
        </_parseDistroRid>



        <_parseDistroRid
            Condition="
                    '$(_parseDistroRid)' == ''
                and
                    '$(MSBuildRuntimeType)' == 'core'
            "
        >

            $(
                  [System.Runtime.InteropServices.RuntimeInformation]
                ::RuntimeIdentifier
            )

        </_parseDistroRid>



        <_parseDistroRid
            Condition="
                    '$(_parseDistroRid)' == ''
                and
                    '$(MSBuildRuntimeType)' != 'core'
            "
        >

            win-$(
                  [System.Runtime.InteropServices.RuntimeInformation]
                ::OSArchitecture
                 .ToString()
                 .ToLowerInvariant
            )

        </_parseDistroRid>



        <_distroRidIndex>
            $(
                _parseDistroRid.LastIndexOf('-')
            )
        </_distroRidIndex>



        <_runtimeOS>
            $(RuntimeOS)
        </_runtimeOS>



        //
        // If $(RuntimeOS) is not set, default to, e.g., the "win" part of "win-x86".
        //

        <_runtimeOS Condition="'$(_runtimeOS)' == ''">
            $(
                _parseDistroRid.SubString(
                    startIndex: 0,
                    length: $(_distroRidIndex)
                )
            )
        </_runtimeOS>



        //
        // <InOriginal>
        //
        // _runtimeOS is calculated based on the build system OS, however if building for
        // Browser/iOS/Android we need to let the build system to use browser/ios/android as the
        // _runtimeOS for produced package RIDs.
        //
        // </InOriginal>
        //

        <_runtimeOS Condition="'$(TargetsMobile)' == 'true'">
            $(TargetOS.ToLowerInvariant())
        </_runtimeOS>



        <_portableOS>
            linux
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'linux-musl'">
            linux-musl
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'linux-bionic'">
            linux-bionic
        </_portableOS>



        <_portableOS Condition="'$(_hostOS)' == 'OSX'">
            osx
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'win' or '$(TargetOS)' == 'windows'">
            win
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'FreeBSD' or '$(TargetOS)' == 'FreeBSD'">
            freebsd
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'illumos' or '$(TargetOS)' == 'illumos'">
            illumos
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'Solaris' or '$(TargetOS)' == 'Solaris'">
            solaris
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'Browser'">
            browser
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'maccatalyst'">
            maccatalyst
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'ios'">
            ios
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'iOSSimulator'">
            iossimulator
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'tvos'">
            tvos
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'tvOSSimulator'">
            tvossimulator
        </_portableOS>



        <_portableOS Condition="'$(_runtimeOS)' == 'android'">
            android
        </_portableOS>



        <_runtimeOS Condition="$(_runtimeOS.StartsWith('tizen'))">
            linux
        </_runtimeOS>



        <_runtimeOS Condition="'$(PortableBuild)' == 'true'">
            $(_portableOS)
        </_runtimeOS>



        <_packageLibc Condition="$(_runtimeOS.Contains('musl'))">
            -musl
        </_packageLibc>



        <_packageOS Condition="'$(CrossBuild)' == 'true'">
            $(_hostOS.ToLowerInvariant)$(_packageLibc)
        </_packageOS>



        <_packageOS Condition="'$(_packageOS)' == '' and '$(PortableBuild)' == 'true'">
            $(_portableOS)
        </_packageOS>



        <_packageOS Condition="'$(_packageOS)' == ''">
            $(_runtimeOS)
        </_packageOS>



    </PropertyGroup> // End of: <PropertyGroup Label="CalculateOS">



    <PropertyGroup Label="CalculateRID">



        <_toolsRID Condition="'$(CrossBuild)' == 'true'">
            $(_hostOS.ToLowerInvariant)-$(_hostArch)
        </_toolsRID>



        <_toolsRID Condition="'$(BuildingInsideVisualStudio)' == 'true'">
            $(_runtimeOS)-x64
        </_toolsRID>



        <_toolsRID Condition="'$(_toolsRID)' == ''">
            $(_runtimeOS)-$(_hostArch)
        </_toolsRID>



        //
        // There are no WebAssembly tools, so use the default ones.
        // </InOriginal>
        //
        ;



        <_toolsRID Condition="'$(_runtimeOS)' == 'browser'">
            linux-x64
        </_toolsRID>



        <_toolsRID Condition="'$(_runtimeOS)' == 'browser' and '$(HostOS)' == 'windows'">
            win-x64
        </_toolsRID>



        <_toolsRID Condition="'$(_runtimeOS)' == 'browser' and '$(HostOS)' == 'osx'">
            osx-x64
        </_toolsRID>



        //
        // <InOriginal>
        // There are no Android tools, so use the default ones.
        // </InOriginal>
        //
        ;



        <_toolsRID Condition="'$(_runtimeOS)' == 'android' or '$(_runtimeOS)' == 'linux-bionic'">
            linux-x64
        </_toolsRID>



        <_toolsRID Condition="('$(_runtimeOS)' == 'android' or '$(_runtimeOS)' == 'linux-bionic') and '$(HostOS)' == 'windows'">
            win-x64
        </_toolsRID>



        <_toolsRID Condition="('$(_runtimeOS)' == 'android' or '$(_runtimeOS)' == 'linux-bionic') and '$(HostOS)' == 'osx'">
            osx-x64
        </_toolsRID>



        //
        // <InOriginal>
        //
        // There are no Mac Catalyst, iOS or tvOS tools and it can be built on OSX only, so use
        // that.
        //
        // </InOriginal>
        //

        <_toolsRID
            Condition="
                    '$(_runtimeOS)' == 'maccatalyst'
                or
                    '$(_runtimeOS)' == 'ios'
                or
                    '$(_runtimeOS)' == 'iOSSimulator'
                or
                    '$(_runtimeOS)' == 'tvos'
                or
                    '$(_runtimeOS)' == 'tvOSSimulator'
            "
        >

            osx-x64

        </_toolsRID>



        //
        // <InOriginal>
        // There are no non-portable builds for Ilasm, Ildasm, ILC etc.
        // </InOriginal>
        //
        ;



        <ToolsRID Condition="'$(PortableBuild)' != 'true' and '$(_portableOS)' == 'linux'">
            linux-$(_hostArch)
        </ToolsRID>



        <ToolsRID Condition="'$(ToolsRID)' == ''">
            $(_toolsRID)
        </ToolsRID>



        <MicrosoftNetCoreIlasmPackageRuntimeId>
            $(ToolsRID)
        </MicrosoftNetCoreIlasmPackageRuntimeId>



        <PackageRID>
            $(_packageOS)-$(TargetArchitecture)
        </PackageRID>



        <OutputRid Condition="'$(OutputRid)' == ''">
            $(PackageRID)
        </OutputRid>



        <OutputRid Condition="'$(PortableBuild)' == 'true'">
            $(_portableOS)-$(TargetArchitecture)
        </OutputRid>



        <TargetsLinuxBionic Condition="$(OutputRid.StartsWith('linux-bionic'))">
            true
        </TargetsLinuxBionic>


    </PropertyGroup> // End of: <PropertyGroup Label="CalculateRID">



    <PropertyGroup Label="CalculateTargetOSName" Condition="'$(SkipInferTargetOSName)' != 'true'">



        <TargetsFreeBSD Condition="'$(TargetOS)' == 'FreeBSD'">
            true
        </TargetsFreeBSD>



        <Targetsillumos Condition="'$(TargetOS)' == 'illumos'">
            true
        </Targetsillumos>



        <TargetsSolaris Condition="'$(TargetOS)' == 'Solaris'">
            true
        </TargetsSolaris>



        <TargetsLinux Condition="'$(TargetOS)' == 'Linux' or '$(TargetOS)' == 'Android'">
            true
        </TargetsLinux>



        <TargetsNetBSD Condition="'$(TargetOS)' == 'NetBSD'">
            true
        </TargetsNetBSD>



        <TargetsOSX Condition="'$(TargetOS)' == 'OSX'">
            true
        </TargetsOSX>



        <TargetsMacCatalyst Condition="'$(TargetOS)' == 'MacCatalyst'">
            true
        </TargetsMacCatalyst>



        <TargetsiOS Condition="'$(TargetOS)' == 'iOS' or '$(TargetOS)' == 'iOSSimulator'">
            true
        </TargetsiOS>



        <TargetstvOS Condition="'$(TargetOS)' == 'tvOS' or '$(TargetOS)' == 'tvOSSimulator'">
            true
        </TargetstvOS>



        <TargetsiOSSimulator Condition="'$(TargetOS)' == 'iOSSimulator'">
            true
        </TargetsiOSSimulator>



        <TargetstvOSSimulator Condition="'$(TargetOS)' == 'tvOSSimulator'">
            true
        </TargetstvOSSimulator>



        <TargetsAndroid Condition="'$(TargetOS)' == 'Android'">
            true
        </TargetsAndroid>



        <TargetsBrowser Condition="'$(TargetOS)' == 'Browser'">
            true
        </TargetsBrowser>



        <TargetsWindows Condition="'$(TargetOS)' == 'windows'">
            true
        </TargetsWindows>



        <TargetsUnix
            Condition="
                    '$(TargetsFreeBSD)' == 'true'
                or
                    '$(Targetsillumos)' == 'true'
                or
                    '$(TargetsSolaris)' == 'true'
                or
                    '$(TargetsLinux)' == 'true'
                or
                    '$(TargetsNetBSD)' == 'true'
                or
                    '$(TargetsOSX)' == 'true'
                or
                    '$(TargetsMacCatalyst)' == 'true'
                or
                    '$(TargetstvOS)' == 'true'
                or
                    '$(TargetsiOS)' == 'true'
                or
                    '$(TargetsAndroid)' == 'true'
            "
        >

            true

        </TargetsUnix>


    </PropertyGroup> // End of: <PropertyGroup Label="CalculateTargetOSName" Condition="'$(SkipInferTargetOSName)' != 'true'">



    <PropertyGroup>



        <MicrosoftNetCoreAppRefPackDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'microsoft.netcore.app.ref'))
        </MicrosoftNetCoreAppRefPackDir>



        <MicrosoftNetCoreAppRefPackRefDir>
            $([MSBuild]::NormalizeDirectory('$(MicrosoftNetCoreAppRefPackDir)', 'ref', '$(NetCoreAppCurrent)'))
        </MicrosoftNetCoreAppRefPackRefDir>



        <MicrosoftNetCoreAppRefPackDataDir>
            $([MSBuild]::NormalizeDirectory('$(MicrosoftNetCoreAppRefPackDir)', 'data'))
        </MicrosoftNetCoreAppRefPackDataDir>



        <MicrosoftNetCoreAppRuntimePackDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', 'microsoft.netcore.app.runtime.$(PackageRID)', '$(LibrariesConfiguration)'))
        </MicrosoftNetCoreAppRuntimePackDir>



        <MicrosoftNetCoreAppRuntimePackRidDir>
            $([MSBuild]::NormalizeDirectory('$(MicrosoftNetCoreAppRuntimePackDir)', 'runtimes', '$(PackageRID)'))
        </MicrosoftNetCoreAppRuntimePackRidDir>



        <MicrosoftNetCoreAppRuntimePackRidLibTfmDir>
            $([MSBuild]::NormalizeDirectory('$(MicrosoftNetCoreAppRuntimePackRidDir)', 'lib', '$(NetCoreAppCurrent)'))
        </MicrosoftNetCoreAppRuntimePackRidLibTfmDir>



        <MicrosoftNetCoreAppRuntimePackNativeDir>
            $([MSBuild]::NormalizeDirectory('$(MicrosoftNetCoreAppRuntimePackRidDir)', 'native'))
        </MicrosoftNetCoreAppRuntimePackNativeDir>


    </PropertyGroup>



    <PropertyGroup>


        <DotNetHostBinDir>
            $([MSBuild]::NormalizeDirectory('$(ArtifactsBinDir)', '$(OutputRid).$(HostConfiguration)', 'corehost'))
        </DotNetHostBinDir>


    </PropertyGroup>



    //
    // <InOriginal>
    // Feature switches.
    // </InOriginal>
    //

    <PropertyGroup>



        <EnableNgenOptimization
            Condition="

                    '$(EnableNgenOptimization)' == ''

                and

                    (
                            '$(Configuration)' == 'Release'
                        or
                            '$(Configuration)' == 'Checked'
                    )
            "
        >

            true

        </EnableNgenOptimization>



        //
        // <InOriginal>
        // Enable NuGet static graph evaluation to optimize incremental restore.
        // </InOriginal>
        //

        <RestoreUseStaticGraphEvaluation>
            true
        </RestoreUseStaticGraphEvaluation>



        //
        // <InOriginal>
        //
        // Turn off end of life target framework checks as we intentionally build older .NETCoreApp
        // configurations.
        //
        // </InOriginal>
        //

        <CheckEolTargetFramework>
            false
        </CheckEolTargetFramework>



        //
        // <InOriginal>
        // Turn off workload support until we support them.
        // </InOriginal>
        //

        <MSBuildEnableWorkloadResolver>
            false
        </MSBuildEnableWorkloadResolver>



        //
        // <InOriginal>
        // Disable source link when building locally.
        // </InOriginal>
        //

        <DisableSourceLink
            Condition="
                    '$(DisableSourceLink)' == ''
                and
                    '$(ContinuousIntegrationBuild)' != 'true'
                and
                    '$(OfficialBuildId)' == ''
            "
        >

            true

        </DisableSourceLink>


    </PropertyGroup>



    //
    // Import some projects found under the repo's top-level "eng" directory (as configured in
    // the Arcade RepoLayout.props file that is included when including the Arcade SDK above).
    //
    // For example: l:\Git\github\dotnet\runtime\eng\...
    //
    // See the listings of the following files for more information:
    //
    //      {l:\Git\github\dotnet\runtime\eng\native\naming.props}
    //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
    //
    // In particular, importing Subsets.props fills the ProjectToBuild item group with a rich
    // description of the nature and order of the full universe of project files that need to
    // be built in order to carry out all of the actions associated with the requested build
    // subsets.
    //
    ;



    <Import Project="$(RepositoryEngineeringDir)native\naming.props" />



    <Import Project="$(RepositoryEngineeringDir)Subsets.props" />



    <Import Project="$(RepositoryEngineeringDir)Analyzers.props" />



    <PropertyGroup>



        <CoreLibSharedDir>
            $([MSBuild]::NormalizeDirectory('$(LibrariesProjectRoot)', 'System.Private.CoreLib', 'src'))
        </CoreLibSharedDir>



        <CoreLibRefDir>
            $([MSBuild]::NormalizeDirectory('$(LibrariesProjectRoot)', 'System.Private.CoreLib', 'ref'))
        </CoreLibRefDir>



        <CoreLibProject Condition="'$(RuntimeFlavor)' == 'CoreCLR'">
            $([MSBuild]::NormalizePath('$(CoreClrProjectRoot)', 'System.Private.CoreLib', 'System.Private.CoreLib.csproj'))
        </CoreLibProject>



        <CoreLibProject Condition="'$(RuntimeFlavor)' == 'Mono'">
            $([MSBuild]::NormalizePath('$(MonoProjectRoot)', 'System.Private.CoreLib', 'System.Private.CoreLib.csproj'))
        </CoreLibProject>



        <CoreLibProject Condition="'$(UseNativeAotCoreLib)' == 'true'">
            $([MSBuild]::NormalizePath('$(CoreClrProjectRoot)', 'nativeaot', 'System.Private.CoreLib', 'src', 'System.Private.CoreLib.csproj'))
        </CoreLibProject>



        <UriProject>
            $([MSBuild]::NormalizePath('$(LibrariesProjectRoot)', 'System.Private.Uri', 'src', 'System.Private.Uri.csproj'))
        </UriProject>



        //
        // <InOriginal>
        // This property is used by the SDK to pull in mono-based runtime packs.
        // </InOriginal>
        //

        <UseMonoRuntime Condition="'$(UseMonoRuntime)' == '' and '$(RuntimeFlavor)' == 'Mono'">
            true
        </UseMonoRuntime>


    </PropertyGroup>



    //
    // <InOriginal>
    // Packaging.
    // </InOriginal>
    //

    <PropertyGroup>



        <GitHubRepositoryName>
            runtime
        </GitHubRepositoryName>



        <RepositoryUrl>
            https://github.com/dotnet/$(GitHubRepositoryName)
        </RepositoryUrl>



        <PackageProjectUrl>
            https://dot.net
        </PackageProjectUrl>



        <Owners>
            microsoft,dotnetframework
        </Owners>



        <IncludeSymbols>
            true
        </IncludeSymbols>



        <LicenseFile>
            $(MSBuildThisFileDirectory)LICENSE.TXT
        </LicenseFile>



        <PackageLicenseExpression>
            MIT
        </PackageLicenseExpression>



        <PackageRequireLicenseAcceptance>
            false
        </PackageRequireLicenseAcceptance>



        <Copyright>
            $(CopyrightNetFoundation)
        </Copyright>



        <PackageThirdPartyNoticesFile>
            $(MSBuildThisFileDirectory)THIRD-PARTY-NOTICES.TXT
        </PackageThirdPartyNoticesFile>



        <PackageReleaseNotes>
            https://go.microsoft.com/fwlink/?LinkID=799421
        </PackageReleaseNotes>



        <IsPrivateAssembly>
            $(MSBuildProjectName.Contains('Private'))
        </IsPrivateAssembly>



        //
        // <InOriginal>
        // Private packages should not be stable.
        // </InOriginal>
        //

        <SuppressFinalPackageVersion Condition="'$(SuppressFinalPackageVersion)' == '' and $(IsPrivateAssembly)">
            true
        </SuppressFinalPackageVersion>



        //
        // <InOriginal>
        // We don't want Private packages to be shipped to NuGet.org.
        // </InOriginal>
        //

        <IsShippingPackage Condition="$(IsPrivateAssembly)">
            false
        </IsShippingPackage>



        <PlaceholderFile>
            $(RepositoryEngineeringDir)_._
        </PlaceholderFile>


    </PropertyGroup>



    //
    // <InOriginal>
    // Language configuration.
    // </InOriginal>
    //

    <PropertyGroup>



        //
        // <InOriginal>
        // Default to allowing all language features.
        // </InOriginal>
        //
        ;



        <LangVersion>
            preview
        </LangVersion>



        <LangVersion Condition="'$(MSBuildProjectExtension)' == '.vbproj'">
            latest
        </LangVersion>



        //
        // <InOriginal>
        // Default to max warnlevel.
        // </InOriginal>
        //

        <AnalysisLevel Condition="'$(MSBuildProjectExtension)' == '.csproj'">
            preview
        </AnalysisLevel>



        //
        // <InOriginal>
        // Enables Strict mode for Roslyn compiler.
        // </InOriginal>
        //

        <Features>
            strict;
            nullablePublicOnly
        </Features>



        <TreatWarningsAsErrors>
            true
        </TreatWarningsAsErrors>



        //
        // <InOriginal>
        // Warnings to always disable.
        // </InOriginal>
        //

        <NoWarn>
            $(NoWarn),CS8969
        </NoWarn>



        //
        // <InOriginal>
        // Always pass portable to override arcade sdk which uses embedded for local builds.
        // </InOriginal>
        //

        <DebugType>
            portable
        </DebugType>



        <DebugSymbols>
            true
        </DebugSymbols>



        //
        // <InOriginal>
        // Default to discarding symbols if not explicitly set.
        // </InOriginal>
        //

        <KeepNativeSymbols Condition="'$(KeepNativeSymbols)' == ''">
            false
        </KeepNativeSymbols>



        //
        // <InOriginal>
        // Used for launchSettings.json and runtime config files.
        // </InOriginal>
        //

        <AppDesignerFolder>
            Properties
        </AppDesignerFolder>



        //
        // <InOriginal>
        // By default the SDK produces ref assembly for 5.0 or later.
        // </InOriginal>
        //

        <ProduceReferenceAssembly>
            false
        </ProduceReferenceAssembly>


    </PropertyGroup>



    <PropertyGroup>



        //
        // Ref:
        //
        //    [[
        //      l:\Git\github\dotnet\runtime $ type eng\NoTargetsSdk.BeforeTargets.targets
        //      <Project>
        //
        //        <PropertyGroup>
        //          <!-- NoTargets SDK needs a TFM set. Set a default if the project doesn't multi target. -->
        //          <TargetFramework Condition="'$(TargetFramework)' == '' and '$(TargetFrameworks)' == ''">$(NetCoreAppCurrent)</TargetFramework>
        //        </PropertyGroup>
        //
        //      </Project>
        //    ]]
        //

        <CustomBeforeNoTargets>
            $(RepositoryEngineeringDir)NoTargetsSdk.BeforeTargets.targets
        </CustomBeforeNoTargets>



        //
        // Ref:
        //
        //    [[
        //      l:\Git\github\dotnet\runtime $ type eng\NoTargetsSdk.AfterTargets.targets
        //      <Project>
        //
        //        <!-- Reset the following target to avoid copying references to an output directory.
        //             TODO: Remove when https://github.com/microsoft/MSBuildSdks/pull/395 is merged. -->
        //        <Target Name="CopyFilesToOutputDirectory" />
        //
        //      </Project>
        //    ]]
        //

        <CustomAfterNoTargets>
            $(RepositoryEngineeringDir)NoTargetsSdk.AfterTargets.targets
        </CustomAfterNoTargets>



        //
        // Ref:
        //
        //    [[
        //      l:\Git\github\dotnet\runtime $ type eng\TraversalSdk.AfterTargets.targets
        //      <Project>
        //
        //        <PropertyGroup>
        //          <TraversalGlobalProperties>BuildAllProjects=true</TraversalGlobalProperties>
        //        </PropertyGroup>
        //
        //        <!-- Uses the Microsoft.DotNet.Build.Tasks.TargetFramework package to filter out target frameworks from ProjectReferences. -->
        //        <PropertyGroup Condition="'$(FilterTraversalProjectReferences)' == 'true'">
        //          <BuildDependsOn>$(BuildDependsOn);ResolveP2PReferences</BuildDependsOn>
        //          <CleanDependsOn>$(CleanDependsOn);ResolveP2PReferences</CleanDependsOn>
        //          <RebuildDependsOn>$(RebuildDependsOn);ResolveP2PReferences</RebuildDependsOn>
        //          <TestDependsOn>$(TestDependsOn);ResolveP2PReferences</TestDependsOn>
        //          <VSTestDependsOn>$(VSTestDependsOn);ResolveP2PReferences</VSTestDependsOn>
        //          <PackDependsOn>$(PackDependsOn);ResolveP2PReferences</PackDependsOn>
        //          <PublishDependsOn>$(PublishDependsOn);ResolveP2PReferences</PublishDependsOn>
        //          <GetTargetPathDependsOn>ResolveP2PReferences</GetTargetPathDependsOn>
        //          <!-- Filter out ProjectReferences which aren't compatible with the project's TargetFramework. -->
        //          <OmitIncompatibleProjectReferences>true</OmitIncompatibleProjectReferences>
        //        </PropertyGroup>
        //
        //        <ItemGroup Condition="'$(FilterTraversalProjectReferences)' == 'true'">
        //          <!-- Override the Traversal SDK setting as filtering relies on the TargetFrameworkProperties being fetched
        //               and don't flow the BuildTargetFramework property down. -->
        //          <ProjectReference Update="@(ProjectReference)"
        //                            SkipGetTargetFrameworkProperties="false"
        //                            UndefineProperties="%(UndefineProperties);BuildTargetFramework"  />
        //        </ItemGroup>
        //
        //      </Project>
        //    ]]
        //

        <CustomAfterTraversalTargets>
            $(RepositoryEngineeringDir)TraversalSdk.AfterTargets.targets
        </CustomAfterTraversalTargets>


    </PropertyGroup>


</Project>






{l:\Git\github\dotnet\runtime\Directory.Build.targets}


    //
    // Notes:
    //
    //    .
    //      See the the {l:\Git\github\dotnet\runtime\Build.proj} file listing and
    //      #NATURE_OF_DIRECTORY_DOT_BUILD_FILES for information on how build.cmd operations end up
    //      calling through into this project file.
    //

<Project>


    <PropertyGroup>



        //
        // <InOriginal>
        //
        // For non-SDK projects that import this file and then import Microsoft.Common.targets,
        // tell Microsoft.Common.targets not to import Directory.Build.targets again.
        //
        // </InOriginal>
        //

        <ImportDirectoryBuildTargets>
            false
        </ImportDirectoryBuildTargets>


    </PropertyGroup>



    <Import Project="Sdk.targets"
        Sdk="Microsoft.DotNet.Arcade.Sdk"
    />



    <Import Project="$(RepositoryEngineeringDir)liveBuilds.targets" />



    <Import Project="$(RepositoryEngineeringDir)generators.targets" />



    <Import Project="$(RepositoryEngineeringDir)python.targets" />



    //
    // <InOriginal>
    //
    // When .NET gets built from source, make the SDK aware there are bootstrap packages for
    // Microsoft.NETCore.App.Runtime.<rid> and Microsoft.NETCore.App.Crossgen2.<rid>.
    //
    // </InOriginal>
    //

    <ItemGroup Condition="'$(DotNetBuildFromSource)' == 'true'">


        <KnownFrameworkReference
            Update="
                @(
                  KnownFrameworkReference
                    ->WithMetadataValue('Identity', 'Microsoft.NETCore.App')
                    ->WithMetadataValue('TargetFramework', '$(NetCoreAppCurrent)')
                )
            "
        >

            <RuntimePackRuntimeIdentifiers>
                $(PackageRID)
            </RuntimePackRuntimeIdentifiers>


        </KnownFrameworkReference>



        <KnownCrossgen2Pack
            Update="
                @(
                  KnownCrossgen2Pack
                    ->WithMetadataValue('Identity', 'Microsoft.NETCore.App.Crossgen2')
                    ->WithMetadataValue('TargetFramework', '$(NetCoreAppCurrent)')
                )
            "
        >

            <Crossgen2RuntimeIdentifiers>$(PackageRID)</Crossgen2RuntimeIdentifiers>

        </KnownCrossgen2Pack>



        //
        // <InOriginal>
        // Avoid references to Microsoft.AspNetCore.App.Runtime.<rid>.
        // </InOriginal>
        //

        <KnownFrameworkReference
            Remove="Microsoft.AspNetCore.App"
        />


    </ItemGroup> // End of: <ItemGroup Condition="'$(DotNetBuildFromSource)' == 'true'">



    <PropertyGroup>



        //
        // <InOriginal>
        //
        // Define this here (not just in Versions.props) because the SDK resets it unconditionally
        // in Microsoft.NETCoreSdk.BundledVersions.props.
        //
        // </InOriginal>
        //

        <NETCoreAppMaximumVersion>
            $(MajorVersion).$(MinorVersion)
        </NETCoreAppMaximumVersion>



        <EnableNETAnalyzers Condition="'$(EnableNETAnalyzers)' == ''">
            $(RunAnalyzers)
        </EnableNETAnalyzers>



        //
        // <InOriginal>
        // SDK sets product to assembly but we want it to be our product name.
        // </InOriginal>
        //

        <Product>
            Microsoft%AE .NET
        </Product>



        //
        // <InOriginal>
        // Use the .NET product branding version for informational version description.
        // </InOriginal>
        //
        ;



        <InformationalVersion Condition="'$(InformationalVersion)' == '' and '$(VersionSuffix)' == ''">
            $(ProductVersion)
        </InformationalVersion>



        <InformationalVersion Condition="'$(InformationalVersion)' == '' and '$(VersionSuffix)' != ''">
            $(ProductVersion)-$(VersionSuffix)
        </InformationalVersion>



    </PropertyGroup>



    <ItemGroup>


        <SupportedNETCoreAppTargetFramework
            Include=".NETCoreApp,Version=v$(NETCoreAppMaximumVersion)"
            DisplayName=".NET $(NETCoreAppMaximumVersion)"
            Alias="net$(NETCoreAppMaximumVersion)"
        />


    </ItemGroup>



    //
    // <InOriginal>
    //
    // The Default behavior in VS is to show files for the first target framework in
    // TargetFrameworks property.
    //
    // This is required to show all the files corresponding to all target frameworks in VS.
    //
    // </InOriginal>
    //

    <ItemGroup
        Condition="

                '$(DefaultLanguageSourceExtension)' != ''

            and

                (
                        '$(BuildingInsideVisualStudio)' == 'true'
                    or
                        '$(DesignTimeBuild)' == 'true'
                )
        "
    >

        <None

            Include="
                $(MSBuildProjectDirectory)\**\*$(DefaultLanguageSourceExtension)
            "

            Exclude="
                $(DefaultItemExcludes);
                $(DefaultExcludesInProjectFolder);
                @(Compile)
            "
        />

    </ItemGroup>



    //
    // <InOriginal>
    // Packaging.
    // </InOriginal>
    //
    ;



    <ItemGroup Condition="'$(IsPackable)' == 'true'">



        //
        // <InOriginal>
        // The sfxproj files add the license themselves.
        // </InOriginal>
        //

        <None
            Condition="
                    '$(MSBuildProjectExtension)' != '.sfxproj'
                and
                    '$(MSBuildProjectFile)' != 'msi.csproj'
            "
            Pack="true"
            Include="$(LicenseFile)"
            PackagePath="$([System.IO.Path]::GetFileName('$(LicenseFile)'))"
        />



        <None
            Pack="true"
            Include="$(PackageThirdPartyNoticesFile)"
            PackagePath="$([System.IO.Path]::GetFileName('$(PackageThirdPartyNoticesFile)'))"
        />


    </ItemGroup> // End of: <ItemGroup Condition="'$(IsPackable)' == 'true'">



    <PropertyGroup>


        <PackageDescription Condition="'$(PackageDescription)' == '' and '$(Description)' != ''">
            $(Description)
        </PackageDescription>



        <RuntimePackageDisclaimer>
            Internal implementation package not meant for direct consumption. Please do not reference directly.
        </RuntimePackageDisclaimer>



        <UseRuntimePackageDisclaimer
            Condition="

                    '$(UseRuntimePackageDisclaimer)' == ''

                and

                    (
                            $(MSBuildProjectName.StartsWith('runtime.native'))
                        or
                            '$(PackageTargetRuntime)' != ''
                    )
            "
        >

            true

        </UseRuntimePackageDisclaimer>



        <PackageDescription Condition="'$(PackageDescription)' != '' and '$(UseRuntimePackageDisclaimer)' == 'true'">
            $(RuntimePackageDisclaimer) %0A$(PackageDescription)
        </PackageDescription>



        <PackageDescription Condition="'$(PackageDescription)' == '' and '$(UseRuntimePackageDisclaimer)' == 'true'">
            $(RuntimePackageDisclaimer)
        </PackageDescription>



        //
        // <InOriginal>
        // Keep in sync as required by the Packaging SDK in Arcade.
        // </InOriginal>
        //

        <Description>
            $(PackageDescription)
        </Description>


    </PropertyGroup>



    //
    // <InOriginal>
    //
    // Arcade SDK versioning is defined by static properties in a targets file.
    //
    // Work around this by moving properties based on versioning into a target.
    //
    // </InOriginal>
    //

    <Target Name="GetProductVersions">



        <PropertyGroup>



            <IncludePreReleaseLabelInPackageVersion Condition="'$(DotNetFinalVersionKind)' != 'release'">
                true
            </IncludePreReleaseLabelInPackageVersion>



            <IncludePreReleaseLabelInPackageVersion Condition="'$(SuppressFinalPackageVersion)' == 'true'">
                true
            </IncludePreReleaseLabelInPackageVersion>



            <IncludePreReleaseLabelInPackageVersion Condition="'$(IsShipping)' != 'true'">
                true
            </IncludePreReleaseLabelInPackageVersion>



            <IncludeBuildNumberInPackageVersion Condition="'$(StabilizePackageVersion)' != 'true'">
                true
            </IncludeBuildNumberInPackageVersion>



            <IncludeBuildNumberInPackageVersion Condition="'$(SuppressFinalPackageVersion)' == 'true'">
                true
            </IncludeBuildNumberInPackageVersion>



            <IncludeBuildNumberInPackageVersion Condition="'$(IsShipping)' != 'true'">
                true
            </IncludeBuildNumberInPackageVersion>



            <ProductVersionSuffix Condition="'$(IncludePreReleaseLabelInPackageVersion)' == 'true'">
                -$(VersionSuffix)
            </ProductVersionSuffix>



            <ProductBandVersion Condition="'$(ProductBandVersion)' == ''">
                $(MajorVersion).$(MinorVersion)
            </ProductBandVersion>



            <ProductionVersion Condition="'$(ProductionVersion)' == ''">
                $(ProductBandVersion).$(PatchVersion)
            </ProductionVersion>



            <ProductVersion>
                $(ProductionVersion)$(ProductVersionSuffix)
            </ProductVersion>



            <SharedFrameworkNugetVersion>
                $(ProductVersion)
            </SharedFrameworkNugetVersion>



            <NuGetVersion>
                $(SharedFrameworkNugetVersion)
            </NuGetVersion>



            <InstallersRelativePath>
                Runtime/$(SharedFrameworkNugetVersion)/
            </InstallersRelativePath>



            //
            // <InOriginal>
            //
            // By default, we are always building the nuget packages for HostPolicy, HostFXR and
            // Dotnet/AppHost.
            //
            // Thus, the properties (below) are always set to $(ProductVersion).
            //
            // However, there are scenarios when only some of these components will change (e.g.,
            // during servicing, we may only change HostPolicy but not HostFXR and Dotnet/AppHost).
            //
            // In such cases, pass the appropriate version value(s) as argument to the build command in
            // order to override (e.g. 'build -p:HostPolicyVersion=x.y.z ...').
            //
            // </InOriginal>
            //
            ;



            <HostVersion Condition="'$(HostVersion)' == ''">
                $(ProductVersion)
            </HostVersion>



            <AppHostVersion Condition="'$(AppHostVersion)' == ''">
                $(ProductVersion)
            </AppHostVersion>



            <HostResolverVersion Condition="'$(HostResolverVersion)' == ''">
                $(ProductVersion)
            </HostResolverVersion>



            <HostPolicyVersion Condition="'$(HostPolicyVersion)' == ''">
                $(ProductVersion)
            </HostPolicyVersion>


        </PropertyGroup>


    </Target> // End of: <Target Name="GetProductVersions">


</Project>






{l:\Git\github\dotnet\runtime\eng\native\naming.props}


    //
    // This file is reached, e.g., along the following import stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\native\naming.props}
    //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
    //      ...
    //

<Project>



    <PropertyGroup>



        <StaticLibPrefix>
            lib
        </StaticLibPrefix>



        <ExeSuffix Condition="'$(HostOS)' == 'windows'">
            .exe
        </ExeSuffix>


    </PropertyGroup>



    //
    // <InOriginal>
    // Add path globs specific to native binaries to exclude unnecessary files from packages.
    // </InOriginal>
    //

    <Choose>



        <When Condition="$(PackageRID.StartsWith('win'))">
            <PropertyGroup>
                <LibSuffix>.dll</LibSuffix>
                <StaticLibSuffix>.lib</StaticLibSuffix>
                <SymbolsSuffix>.pdb</SymbolsSuffix>
            </PropertyGroup>
        </When>



        <When
            Condition="
                    $(PackageRID.StartsWith('osx'))
                or
                    $(PackageRID.StartsWith('maccatalyst'))
                or
                    $(PackageRID.StartsWith('ios'))
                or
                    $(PackageRID.StartsWith('tvos'))
            "
        >
            <PropertyGroup>
                <LibPrefix>lib</LibPrefix>
                <LibSuffix>.dylib</LibSuffix>
                <StaticLibSuffix>.a</StaticLibSuffix>
                <SymbolsSuffix>.dwarf</SymbolsSuffix>
            </PropertyGroup>
        </When>



        <Otherwise>
            <PropertyGroup>
                <LibPrefix>lib</LibPrefix>
                <LibSuffix>.so</LibSuffix>
                <StaticLibSuffix>.a</StaticLibSuffix>
                <SymbolsSuffix>.dbg</SymbolsSuffix>
            </PropertyGroup>
        </Otherwise>


    </Choose>



    <ItemGroup>



        <AdditionalLibPackageExcludes
            Condition="'$(SymbolsSuffix)' != ''"
            Include="%2A%2A\%2A$(SymbolsSuffix)"
        >



        <AdditionalSymbolPackageExcludes
            Condition="'$(LibSuffix)' != ''"
            Include="%2A%2A\%2A.a;%2A%2A\%2A$(LibSuffix)"
        />


    </ItemGroup>


</Project>






{l:\Git\github\dotnet\runtime\eng\Subsets.props}


    //
    // This file is reached, e.g., along the following import stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
    //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
    //      ...
    //


<Project>



    //
    // <InOriginal>
    //
    // #
    //
    // This file defines the list of projects to build and divides them into subsets.
    //
    // In ordinary situations, you should perform a full build by running 'build.cmd' or
    // './build.sh'.
    //
    // This ensures the projects are sequenced correctly so the outputs and test results are
    // what you would expect.
    //
    //
    // #
    //
    // Examples:
    //
    //
    //      #
    //
    //      ./build.sh host.native
    //
    //      This builds only the .NET host.
    //
    //
    //      #
    //
    //      ./build.sh libs+host.native
    //
    //      This builds the .NET host and also the manged libraries portion.
    //
    //      A space ' ' or '+' are the delimiters between multiple subsets to build.
    //
    //
    //      #
    //
    //      ./build.sh -test host.tests
    //
    //      This builds and executes the installer test projects.
    //
    //      (The '-test' argument is an Arcade SDK argument that indicates tests should be run;
    //      otherwise, they'll only be built.)
    //
    // </InOriginal>
    //
    ;



    //
    // <InOriginal>
    //
    // Determine the primary runtime flavor.
    //
    // This is usually CoreCLR, except on platforms (like s390x) where only Mono is supported.
    //
    // The primary runtime flavor is used to decide when to build the hosts and installers.
    //
    // </InOriginal>
    //

    <PropertyGroup>



        <PrimaryRuntimeFlavor>
            CoreCLR
        </PrimaryRuntimeFlavor>



        <PrimaryRuntimeFlavor
            Condition="
                    '$(TargetArchitecture)' == 's390x'
                or
                    '$(TargetArchitecture)' == 'ppc64le'
                or
                    '$(TargetArchitecture)' == 'armv6'
                or
                    '$(TargetsLinuxBionic)' == 'true'
            "
        >

            Mono

        </PrimaryRuntimeFlavor>


    </PropertyGroup>



    <PropertyGroup>



        <DefaultSubsets>
            clr+mono+libs+host+packs
        </DefaultSubsets>



        <DefaultSubsets Condition="'$(TargetsMobile)' == 'true'">
            mono+libs+packs
        </DefaultSubsets>



        <DefaultSubsets Condition="'$(TargetsLinuxBionic)' == 'true'">
            mono+libs+host+packs
        </DefaultSubsets>



        //
        // <InOriginal>
        //
        // In source build, mono is only supported as primary runtime flavor.
        //
        // On Windows mono is supported for x86/x64 only.
        //
        // </InOriginal>
        //
        // I think the idea is to take the
        //
        //      clr+mono+libs+host+packs
        //
        // setting applied above and trim it down to
        //
        //      clr+libs+host+packs
        //
        // (i.e., remove mono but leave everything else unchanged) in the cases discussed in the
        // product comment above.
        //

        <DefaultSubsets
            Condition="

                    (
                            '$(DotNetBuildFromSource)' == 'true'
                        and
                            '$(PrimaryRuntimeFlavor)' != 'Mono'
                    )

                or

                    (
                            '$(TargetOS)' == 'windows'
                        and
                            '$(TargetArchitecture)' != 'x86'
                        and
                            '$(TargetArchitecture)' != 'x64'
                    )
            "
        >

            clr+libs+host+packs

        </DefaultSubsets>


    </PropertyGroup>



    //
    // <InOriginal>
    // Init _subset here to allow RuntimeFlavor to be set as early as possible.
    // </InOriginal>
    //

    <PropertyGroup>



        <_subset Condition="'$(Subset)' != ''">
            +$(Subset.ToLowerInvariant())+
        </_subset>



        <_subset Condition="'$(Subset)' == ''">
            +$(DefaultSubsets)+
        </_subset>


    </PropertyGroup>



    <PropertyGroup>



        <RuntimeFlavor Condition="'$(TargetsMobile)' == 'true'">
            Mono
        </RuntimeFlavor>



        <RuntimeFlavor
            Condition="

                    '$(RuntimeFlavor)' == ''

                and

                    (
                            $(_subset.Contains('+mono+'))
                        or
                            $(_subset.Contains('+mono.runtime+'))
                    )

                and

                    (
                           !$(_subset.Contains('+clr+'))
                        and
                           !$(_subset.Contains('+clr.runtime+'))
                    )
            "
        >

            Mono

        </RuntimeFlavor>



        <RuntimeFlavor Condition="'$(RuntimeFlavor)' == ''">
            $(PrimaryRuntimeFlavor)
        </RuntimeFlavor>


    </PropertyGroup>



    <PropertyGroup>


        <DefaultCoreClrSubsets>
            clr.native+linuxdac+clr.corelib+clr.tools+clr.nativecorelib+clr.packages+clr.nativeaotlibs+clr.crossarchtools+host.native
        </DefaultCoreClrSubsets>



        <DefaultCoreClrSubsets Condition="'$(PackageRID)' == 'linux-armel'">
            clr.native+linuxdac+clr.corelib+clr.tools+clr.nativecorelib+clr.packages+clr.nativeaotlibs+clr.crossarchtools
        </DefaultCoreClrSubsets>



        //
        // <InOriginal>
        //
        // Even on platforms that do not support the CoreCLR runtime, we still want to build
        // ilasm/ildasm.
        //
        // </InOriginal>
        //

        <DefaultCoreClrSubsets Condition="'$(PrimaryRuntimeFlavor)' != 'CoreCLR'">
            clr.iltools+clr.packages
        </DefaultCoreClrSubsets>



        <DefaultNativeAotSubsets>
            clr.alljits+clr.tools+clr.nativeaotlibs+clr.nativeaotruntime
        </DefaultNativeAotSubsets>



        <DefaultMonoSubsets Condition="'$(MonoEnableLLVM)' == 'true' and '$(MonoLLVMDir)' == ''">
            mono.llvm+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets Condition="'$(MonoAOTEnableLLVM)' == 'true' and '$(MonoAOTLLVMDir)' == ''">
            mono.llvm+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets Condition="'$(TargetOS)' == 'Browser'">
            $(DefaultMonoSubsets)mono.wasmruntime+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets Condition="'$(MonoCrossAOTTargetOS)' != ''">
            $(DefaultMonoSubsets)mono.aotcross+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets>
            $(DefaultMonoSubsets)mono.runtime+mono.corelib+mono.packages+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets Condition="'$(PrimaryRuntimeFlavor)' != 'Mono'">
            $(DefaultMonoSubsets)mono.tools+
        </DefaultMonoSubsets>



        <DefaultMonoSubsets Condition="'$(TargetsMobile)' != 'true'">
            $(DefaultMonoSubsets)host.native+
        </DefaultMonoSubsets>



        <DefaultLibrariesSubsets
            Condition="
                    '$(BuildTargetFramework)' == '$(NetCoreAppCurrent)'
                or
                    '$(BuildTargetFramework)' == ''
                or
                    '$(BuildAllConfigurations)' == 'true'
            "
        >

            libs.native+

        </DefaultLibrariesSubsets>



        <DefaultLibrariesSubsets>
            $(DefaultLibrariesSubsets)libs.sfx+libs.oob+libs.pretest
        </DefaultLibrariesSubsets>



        <DefaultHostSubsets>
            host.native+host.tools+host.pkg
        </DefaultHostSubsets>



        <DefaultHostSubsets Condition="'$(DotNetBuildFromSource)' != 'true'">
            $(DefaultHostSubsets)+host.tests
        </DefaultHostSubsets>



        <DefaultHostSubsets Condition="'$(RuntimeFlavor)' != '$(PrimaryRuntimeFlavor)'">
        </DefaultHostSubsets>



        <DefaultHostSubsets Condition="'$(RuntimeFlavor)' != '$(PrimaryRuntimeFlavor)' and '$(TargetsMobile)' != 'true'">
            host.native
        </DefaultHostSubsets>



        <DefaultPacksSubsets>
            packs.product
        </DefaultPacksSubsets>



        <DefaultPacksSubsets Condition="'$(BuildMonoAOTCrossCompilerOnly)' != 'true' and '$(DotNetBuildFromSource)' != 'true'">
            $(DefaultPacksSubsets)+packs.tests
        </DefaultPacksSubsets>



        <DefaultPacksSubsets Condition="'$(DotNetBuildFromSource)' == 'true'">
            $(DefaultPacksSubsets)+packs.installers
        </DefaultPacksSubsets>


    </PropertyGroup>

    <PropertyGroup>



        <_subset>
            $(_subset.Replace('+clr.paltests+', '+clr.paltests+clr.paltestlist+'))
        </_subset>



        //
        // For the following "meta-subsets"
        //
        //      clr         [[ expands to: $(DefaultCoreClrSubsets) ]]
        //      clr.aot     [[ expands to: $(DefaultNativeAotSubsets) ]]
        //      mono        [[ expands to: $(DefaultMonoSubsets) ]]
        //      libs        [[ expands to: $(DefaultLibrariesSubsets) ]]
        //      host        [[ expands to: $(DefaultHostSubsets) ]]
        //      packs       [[ expands to: $(DefaultPacksSubsets) ]]
        //
        // replace any references to the meta-subset with the associated full list of finer-grained
        // subsets that was constructed in the property group above.
        //
        ;



        <_subset>
            $(_subset.Replace('+clr+', '+$(DefaultCoreClrSubsets)+'))
        </_subset>



        <_subset>
            $(_subset.Replace('+clr.aot+', '+$(DefaultNativeAotSubsets)+'))
        </_subset>



        <_subset>
            $(_subset.Replace('+mono+', '+$(DefaultMonoSubsets)+'))
        </_subset>



        <_subset>
            $(_subset.Replace('+libs+', '+$(DefaultLibrariesSubsets)+'))
        </_subset>



        <_subset>
            $(_subset.Replace('+host+', '+$(DefaultHostSubsets)+'))
        </_subset>



        <_subset>
            $(_subset.Replace('+packs+', '+$(DefaultPacksSubsets)+'))
        </_subset>



        //
        // <InOriginal>
        // Surround _subset in a single leading and trailing "+" to simplify checks below.
        // </InOriginal>
        //

        <_subset>
            +$(_subset.Trim('+'))+
        </_subset>



        <ClrRuntimeBuildSubsets>
        </ClrRuntimeBuildSubsets>



        <ClrDefaultRuntimeBuildSubsets>
            ClrRuntimeSubset=true;
            ClrJitSubset=true;
            ClrILToolsSubset=true
        </ClrDefaultRuntimeBuildSubsets>


    </PropertyGroup>



    <PropertyGroup>



        //
        // <InOriginal>
        // CLR NativeAot only builds in a subset of the matrix.
        // </InOriginal>
        //

        <NativeAotSupported
            Condition="

                    (
                            '$(TargetOS)' == 'windows'
                        or
                            '$(TargetOS)' == 'linux'
                        or
                            '$(TargetOS)' == 'OSX'
                    )

                and

                    (
                            '$(TargetArchitecture)' == 'x64'
                        or
                            '$(TargetArchitecture)' == 'arm64'
                    )
            "
        >

            true

        </NativeAotSupported>



        //
        // <InOriginal>
        //
        // If we're building clr.nativeaotlibs and not building the CLR runtime, compile libraries
        // against NativeAOT CoreLib.
        //
        // </InOriginal>
        //

        <UseNativeAotCoreLib
            Condition="
                    $(_subset.Contains('+clr.nativeaotlibs+'))
                and
                   !$(_subset.Contains('+clr.native+'))
                and
                   !$(_subset.Contains('+clr.runtime+'))
            "
        >

            true

        </UseNativeAotCoreLib>


    </PropertyGroup>



    //
    // Define the SubsetName collection which defines the full set of subset identifiers that
    // can be specified in the user-supplied Subset property.
    //
    // During build.cmd operations, the MSBuild logic which enforces this "allow list" (and
    // which prints the full list of allowed identifiers in response to a request for a "help"
    // subset or an unrecognized subset) is pulled in via the following sequence:
    //
    //      {l:\Git\github\dotnet\runtime\eng\SubsetValidation.targets}
    //      {l:\Git\github\dotnet\runtime\Build.proj}
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //

    <ItemGroup>



        //
        // <InOriginal>
        // CoreClr.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="Clr"
            Description="The full CoreCLR runtime. Equivalent to: $(DefaultCoreClrSubsets)"
        />



        <SubsetName
            Include="Clr.NativePrereqs"
            Description="Managed tools that support building the native components of the runtime (such as DacTableGen)."
        />



        <SubsetName
            Include="Clr.ILTools"
            Description="The CoreCLR IL tools (ilasm/ildasm)."
        />



        <SubsetName
            Include="Clr.Runtime"
            Description="The CoreCLR .NET runtime. Includes clr.jit, clr.iltools, clr.hosts."
        />



        <SubsetName
            Include="Clr.Native"
            Description="
                All CoreCLR native non-test components, including the runtime, jits, and other native tools.
                Includes clr.hosts, clr.runtime, clr.jit, clr.alljits, clr.paltests, clr.iltools, clr.nativeaotruntime, clr.spmi.
            "
        />



        <SubsetName
            Include="Clr.Aot"
            Description="Everything needed for Native AOT workloads, including clr.alljits, clr.tools, clr.nativeaotlibs, and clr.nativeaotruntime"
        />



        <SubsetName
            Include="Clr.NativeAotLibs"
            Description="The CoreCLR native AOT CoreLib and other low level class libraries."
        />



        <SubsetName
            Include="Clr.NativeAotRuntime"
            Description="The stripped-down CoreCLR native AOT runtime."
        />



        <SubsetName
            Include="Clr.CrossArchTools"
            Description="The cross-targeted CoreCLR tools."
        />



        <SubsetName
            Include="Clr.PalTests"
            OnDemand="true"
            Description="The CoreCLR PAL tests."
        />



        <SubsetName
            Include="Clr.PalTestList"
            OnDemand="true"
            Description="Generate the list of the CoreCLR PAL tests. When using the command line, use Clr.PalTests instead."
        />



        <SubsetName
            Include="Clr.Hosts"
            Description="The CoreCLR corerun test host."
        />



        <SubsetName
            Include="Clr.Jit"
            Description="The JIT for the CoreCLR .NET runtime."
        />



        <SubsetName
            Include="Clr.AllJits"
            Description="All of the cross-targeting JIT compilers for the CoreCLR .NET runtime."
        />



        <SubsetName
            Include="Clr.Spmi"
            Description="SuperPMI, a tool for CoreCLR JIT testing."
        />



        <SubsetName
            Include="Clr.CoreLib"
            Description="The managed System.Private.CoreLib library for CoreCLR."
        />



        <SubsetName
            Include="Clr.NativeCoreLib"
            Description="Run crossgen on System.Private.CoreLib library for CoreCLR."
        />



        <SubsetName
            Include="Clr.Tools"
            Description="Managed tools that support CoreCLR development and testing."
        />



        <SubsetName
            Include="Clr.ToolsTests"
            OnDemand="true"
            Description="Unit tests for the clr.tools subset."
        />



        <SubsetName
            Include="Clr.Packages"
            Description="The projects that produce NuGet packages for the CoreCLR runtime, crossgen, and IL tools."
        />



        <SubsetName
            Include="LinuxDac"
            Condition="$([MSBuild]::IsOsPlatform(Windows))"
            Description="The cross-OS Windows->libc-based Linux DAC. Skipped on x86."
        />



        <SubsetName
            Include="AlpineDac"
            Condition="$([MSBuild]::IsOsPlatform(Windows))"
            OnDemand="true"
            Description="The cross-OS Windows->musl-libc-based Linux DAC. Skipped on x86"
        />



        <SubsetName
            Include="CrossDacPack"
            OnDemand="true"
            Description="
                Packaging of cross OS DAC. Requires all assets needed to be present at a folder specified by $(CrossDacArtifactsDir).
                See 'Microsoft.CrossOsDiag.Private.CoreCLR.proj' for details.
            "
        />



        //
        // <InOriginal>
        // Mono.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="Mono"
            Description="The Mono runtime and CoreLib. Equivalent to: $(DefaultMonoSubsets)"
        />



        <SubsetName
            Include="Mono.Runtime"
            Description="The Mono .NET runtime."
        />



        <SubsetName
            Include="Mono.AotCross"
            Description="The cross-compiler runtime for Mono AOT."
        />



        <SubsetName
            Include="Mono.CoreLib"
            Description="The managed System.Private.CoreLib library for Mono."
        />



        <SubsetName
            Include="Mono.Packages"
            Description="The projects that produce NuGet packages for the Mono runtime."
        />



        <SubsetName
            Include="Mono.Tools"
            Description="Tooling that helps support Mono development and testing."
        />



        <SubsetName
            Include="Mono.WasmRuntime"
            Description="The WebAssembly runtime."
        />



        <SubsetName
            Include="Mono.MsCorDbi"
            Description="The implementation of ICorDebug interface."
        />



        <SubsetName
            Include="Mono.Workloads" OnDemand="true"
            Description="Builds the installers and the insertion metadata for Blazor workloads."
        />



        //
        // <InOriginal>
        // Host.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="Host"
            Description="The .NET hosts, packages, hosting libraries, and tests. Equivalent to: $(DefaultHostSubsets)"
        />



        <SubsetName
            Include="Host.Native"
            Description="The .NET hosts."
        />



        <SubsetName
            Include="Host.Pkg"
            Description="The .NET host packages."
        />



        <SubsetName
            Include="Host.Tools"
            Description="The .NET hosting libraries."
        />



        <SubsetName
            Include="Host.Tests"
            Description="The .NET hosting tests."
        />



        //
        // <InOriginal>
        // Libs.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="Libs"
            Description="
                The libraries native part, refs and source assemblies, test infra and packages, but NOT the tests
                (use Libs.Tests to request those explicitly). Equivalent to: $(DefaultLibrariesSubsets)
            "
        />



        <SubsetName
            Include="Libs.Native"
            Description="The native libraries used in the shared framework."
        />



        <SubsetName
            Include="Libs.Sfx"
            Description="The managed shared framework libraries."
        />



        <SubsetName
            Include="Libs.Oob"
            Description="The managed out-of-band libraries."
        />



        <SubsetName
            Include="Libs.Ref"
            OnDemand="true"
            Description="The managed reference libraries."
        />



        <SubsetName
            Include="Libs.Src" OnDemand="true"
            Description="The managed implementation libraries."
        />



        <SubsetName
            Include="Libs.PreTest"
            Description="Test assets which are necessary to run tests."
        />



        <SubsetName
            Include="Libs.Tests"
            OnDemand="true"
            Description="The test projects. Note that building this doesn't execute tests: you must also pass the '-test' argument."
        />



        //
        // <InOriginal>
        // Packs.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="Packs"
            Description="Builds the shared framework packs, archives, bundles, installers, and the framework pack tests. Equivalent to: $(DefaultPacksSubsets)"
        />



        <SubsetName
            Include="Packs.Product"
            Description="Builds the shared framework packs, archives, bundles, and installers."
        />



        <SubsetName
            Include="Packs.Installers"
            Description="Builds the shared framework bundles and installers."
        />



        <SubsetName
            Include="Packs.Tests"
            Description="The framework pack tests."
        />



        //
        // <InOriginal>
        // Utility.
        // </InOriginal>
        //
        ;



        <SubsetName
            Include="publish"
            OnDemand="true"
            Description="Generate asset manifests and prepare to publish to BAR."
        />



        <SubsetName
            Include="RegenerateDownloadTable"
            OnDemand="true"
            Description="Regenerates the nightly build download table"
        />



        <SubsetName
            Include="RegenerateThirdPartyNotices"
            OnDemand="true"
            Description="Regenerates the THIRD-PARTY-NOTICES.TXT file based on other repos' TPN files."
        />


    </ItemGroup>



    //
    // <InOriginal>
    // Default targets, parallelization and configurations.
    // </InOriginal>
    //
    // Establish an empty <ProjectToBuild> item group where each item receives the default
    // settings listed below.
    //
    // The eventual <ProjectToBuild> setting will be consumed, e.g., in
    // {l:\Git\github\dotnet\runtime\Build.proj}.
    //

    <ItemDefinitionGroup>
        <ProjectToBuild>
            <Test>false</Test>
            <Pack>false</Pack>
            <Publish>false</Publish>
            <BuildInParallel>false</BuildInParallel>
        </ProjectToBuild>
    </ItemDefinitionGroup>



    //
    // <InOriginal>
    // CoreClr sets.
    // </InOriginal>
    //
    ;



    //
    // Add src\coreclr\System.Private.CoreLib\System.Private.CoreLib.csproj whenever
    // "clr.corelib" is present in the set.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.corelib+'))">


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)System.Private.CoreLib\System.Private.CoreLib.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.corelib+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.hosts+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrHostsSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.hosts+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.runtime+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrRuntimeSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.runtime+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.native+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrFullNativeBuild=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.native+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.jit+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrJitSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.jit+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.paltests+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrPalTestsSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.paltests+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.alljits+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrAllJitsSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.alljits+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.iltools+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrILToolsSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.iltools+'))">



    <PropertyGroup Condition="$(_subset.Contains('+clr.nativeaotruntime+')) and '$(NativeAotSupported)' == 'true'">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrNativeAotSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.nativeaotruntime+')) and '$(NativeAotSupported)' == 'true'">



    <PropertyGroup Condition="$(_subset.Contains('+clr.spmi+'))">


        <ClrRuntimeBuildSubsets>
            $(ClrRuntimeBuildSubsets);ClrSpmiSubset=true
        </ClrRuntimeBuildSubsets>


    </PropertyGroup> // End of: <PropertyGroup Condition="$(_subset.Contains('+clr.spmi+'))">



    //
    // Add src\coreclr\runtime-prereqs.proj whenever one or more CLR runtime build subsets have
    // been requested, or when no such subsets have been requested but "clr.nativeprereqs" has
    // been requested explicitly.
    //

    <ItemGroup Condition="'$(ClrRuntimeBuildSubsets)' != '' or $(_subset.Contains('+clr.nativeprereqs+'))">


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime-prereqs.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="'$(ClrRuntimeBuildSubsets)' != '' or $(_subset.Contains('+clr.nativeprereqs+'))">



    //
    // Add src\coreclr\runtime.proj whenever one or more CLR runtime build subsets have been
    // requested.
    //

    <ItemGroup Condition="'$(ClrRuntimeBuildSubsets)' != ''">


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                $(ClrRuntimeBuildSubsets)
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="'$(ClrRuntimeBuildSubsets)' != ''">



    //
    // <InOriginal>
    //
    // Build the CoreCLR cross-arch tools when we're doing a cross-architecture build and
    // either we're building any CoreCLR native tools for platforms CoreCLR fully supports or
    // when someone explicitly requests them.
    //
    // </InOriginal>
    //
    // If cross tools are needed, add src\coreclr\runtime.proj (maybe for a second time), this
    // time with the ClrCrossComponentsSubset property set.
    //

    <ItemGroup
        Condition="

                '$(BuildArchitecture)' != '$(TargetArchitecture)'

            and

                (
                        (
                                '$(ClrRuntimeBuildSubsets)' != ''
                            and
                                '$(PrimaryRuntimeFlavor)' == 'CoreCLR'
                            and
                                '$(TargetsMobile)' != 'true'
                        )

                    or

                        $(_subset.Contains('+clr.crossarchtools+'))
                )
        "
    >


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                ClrCrossComponentsSubset=true;
                HostArchitecture=$(BuildArchitecture);
                PgoInstrument=false;
                NoPgoOptimize=true;
                CrossBuild=false;
                CMakeArgs=$(CMakeArgs) -DCLR_CROSS_COMPONENTS_BUILD=1
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="<<cross tools are needed>>">



    //
    // If cross tools are being built when building on Windows x64 and targeting arm, then add
    // src\coreclr\runtime.proj one more time, again with the ClrCrossComponentsSubset property
    // set but this time with HostArchitecture forced to x86 (whereas it was x64 in the item
    // group entry added above) to additionally built x86-hosted cross tools.
    //

    <ItemGroup
        Condition="

                $([MSBuild]::IsOsPlatform(Windows))

            and

                '$(BuildArchitecture)' == 'x64'

            and

                '$(TargetArchitecture)' == 'arm'

            and

                (
                        (
                                '$(ClrRuntimeBuildSubsets)' != ''
                            and
                                '$(PrimaryRuntimeFlavor)' == 'CoreCLR'
                            and
                                '$(TargetsMobile)' != 'true'
                        )

                    or

                        $(_subset.Contains('+clr.crossarchtools+'))
                )
        "
    >


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                ClrCrossComponentsSubset=true;
                HostArchitecture=x86;
                PgoInstrument=false;
                NoPgoOptimize=true;
                CrossBuild=false;
                CMakeArgs=$(CMakeArgs) -DCLR_CROSS_COMPONENTS_BUILD=1
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="<<additionaly x86-hosted cross tools are needed>>">



    //
    // Add src\coreclr\pal\tests\palsuite\producepaltestlist.proj if the "clr.paltestlist"
    // subset is being built.
    //
    // Notes:
    //
    //    .
    //      Unlike all surrounding ProjectToBuild additions, this one is NOT tagged with a
    //      Category="clr" attribute.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.paltestlist+'))">


        <ProjectToBuild
            Include="$(CoreClrProjectRoot)pal/tests/palsuite/producepaltestlist.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.paltestlist+'))">



    <PropertyGroup>



        <CrossDacHostArch>
            x64
        </CrossDacHostArch>



        <CrossDacHostArch Condition="'$(TargetArchitecture)' == 'arm'">
            x86
        </CrossDacHostArch>


    </PropertyGroup>



    //
    // If needed, add src\coreclr\runtime.proj one more time, this time with
    // ClrCrossComponentsSubset set and TargetOS forced to "Linux" in order to force creation
    // of a Windows-to-non-x86-Linux cross-DAC.
    //

    <ItemGroup
        Condition="
                $(_subset.Contains('+linuxdac+'))
            and
                $([MSBuild]::IsOsPlatform(Windows))
            and
                '$(TargetArchitecture)' != 'x86'
        "
    >


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                ClrCrossComponentsSubset=true;
                HostArchitecture=$(CrossDacHostArch);
                PgoInstrument=false;
                NoPgoOptimize=true;
                TargetOS=Linux;
                CMakeArgs=$(CMakeArgs) -DCLR_CROSS_COMPONENTS_BUILD=1
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="<<Windows-to-non-x86-Linux cross-DAC is needed>>">



    //
    // If needed, add src\coreclr\runtime.proj one more time, this time with
    // ClrCrossComponentsSubset set and TargetOS forced to "alpine" in order to force creation
    // of a Windows-to-non-x86-Alpine cross-DAC.
    //

    <ItemGroup
        Condition="
                $(_subset.Contains('+alpinedac+'))
            and
                $([MSBuild]::IsOsPlatform(Windows))
            and
                '$(TargetArchitecture)' != 'x86'
        "
    >


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)runtime.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                ClrCrossComponentsSubset=true;
                HostArchitecture=$(CrossDacHostArch);
                PgoInstrument=false;
                NoPgoOptimize=true;
                TargetOS=alpine;
                CMakeArgs=$(CMakeArgs) -DCLR_CROSS_COMPONENTS_BUILD=1
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="<<Windows-to-non-x86-Alpine cross-DAC is needed>>">



    //
    // Add src\coreclr\.nuget\Microsoft.CrossOsDiag.Private.CoreCLR\Microsoft.CrossOsDiag.Private.CoreCLR.proj
    // whenever "crossdacpack" is present in the set.
    //

    <ItemGroup Condition="$(_subset.Contains('+crossdacpack+'))">


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot).nuget\Microsoft.CrossOsDiag.Private.CoreCLR\Microsoft.CrossOsDiag.Private.CoreCLR.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+crossdacpack+'))">



    //
    // If "clr.tools" is included in the set, then add a variety of project files related to
    // crossgen2, the NativeAOT toolchain, etc.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.tools+'))">


        <ProjectToBuild
            Category="clr"
            Condition="'$(DotNetBuildFromSource)' != 'true'"
            Include="
                $(CoreClrProjectRoot)tools\runincontext\runincontext.csproj;
                $(CoreClrProjectRoot)tools\tieringtest\tieringtest.csproj;
                $(CoreClrProjectRoot)tools\r2rdump\R2RDump.csproj;
                $(CoreClrProjectRoot)tools\dotnet-pgo\dotnet-pgo.csproj;
                $(CoreClrProjectRoot)tools\aot\ILCompiler\repro\repro.csproj;
                $(CoreClrProjectRoot)tools\r2rtest\R2RTest.csproj
            "
        />



        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)tools\aot\crossgen2\crossgen2.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(NativeAotSupported)' == 'true'"
            Include="$(CoreClrProjectRoot)tools\aot\ILCompiler.Build.Tasks\ILCompiler.Build.Tasks.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(NativeAotSupported)' == 'true'"
            Include="$(CoreClrProjectRoot)tools\aot\ILCompiler\ILCompiler.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(NativeAotSupported)' == 'true'"
            Include="$(CoreClrProjectRoot)nativeaot\BuildIntegration\BuildIntegration.proj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(NativeAotSupported)' == 'true' and '$(TargetArchitecture)' != '$(BuildArchitecture)'"
            Include="$(CoreClrProjectRoot)tools\aot\ILCompiler\ILCompiler_crossarch.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(TargetArchitecture)' != '$(BuildArchitecture)'"
            Include="$(CoreClrProjectRoot)tools\aot\crossgen2\crossgen2_crossarch.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="

                    '$(TargetOS)' == 'windows'

                or

                    '$(TargetOS)' == 'OSX'

                or

                    (
                            '$(TargetOS)' == 'Linux'

                        and

                            (
                                    '$(TargetArchitecture)' == 'x64'
                                or
                                    '$(TargetArchitecture)' == 'arm64'
                            )
                    )
            "
            Include="$(CoreClrProjectRoot)tools\SuperFileCheck\SuperFileCheck.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.tools+'))">



    //
    // If "clr.toolstests" is included in the set, then add project files related to tests for
    // different AOT-related tools.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.toolstests+'))">



        <ProjectToBuild
            Category="clr"
            Condition="'$(DotNetBuildFromSource)' != 'true'"
            Test="true"
            Include="$(CoreClrProjectRoot)tools\aot\ILCompiler.TypeSystem.Tests\ILCompiler.TypeSystem.Tests.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(DotNetBuildFromSource)' != 'true' and '$(NativeAotSupported)' == 'true'"
            Test="true"
            Include="$(CoreClrProjectRoot)tools\aot\ILCompiler.Compiler.Tests\ILCompiler.Compiler.Tests.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(DotNetBuildFromSource)' != 'true' and '$(NativeAotSupported)' == 'true'"
            Test="true"
            Include="$(CoreClrProjectRoot)tools\aot\Mono.Linker.Tests\Mono.Linker.Tests.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.toolstests+'))">



    //
    // If "clr.nativecorelib" is included in the set, then add project files to establish the
    // required crossgen2 tool and then use it to precompile the System.Private.CoreLib.dll
    // library.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.nativecorelib+'))">



        //
        // <InOriginal>
        // Build crossgen2 that will be used to compile System.Private.CoreLib library for CoreCLR.
        // </InOriginal>
        //
        ;



        <ProjectToBuild
            Category="clr"
            Condition="'$(TargetArchitecture)' != 'x64' and '$(BuildArchitecture)' == 'x64'"
            Include="$(CoreClrProjectRoot)tools\aot\crossgen2\crossgen2_crossarch.csproj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="!('$(TargetArchitecture)' != 'x64' and '$(BuildArchitecture)' == 'x64')"
            Include="$(CoreClrProjectRoot)tools\aot\crossgen2\crossgen2.csproj"
        />



        //
        // Add src\coreclr\crossgen-corelib.proj to run the crossgen2 tool (established via the
        // builds added immediately above) against the System.Private.CoreLib.dll library (e.g.,
        // built by the "clr.corelib" handling above).
        //

        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)crossgen-corelib.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.nativecorelib+'))">



    //
    // If "clr.packages" is included in the set and this is not a PGO instrumented build, then
    // add project files that will publish the build artifacts generated above into associated
    // packages.
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.packages+')) and '$(PgoInstrument)' != 'true'">



        <ProjectToBuild
            Category="clr"
            Pack="true"
            Include="$(CoreClrProjectRoot).nuget\coreclr-packages.proj"
        />



        <ProjectToBuild
            Category="clr"
            Condition="'$(DotNetBuildFromSource)' != 'true' and '$(RuntimeFlavor)' != 'Mono'"
            Pack="true"
            Include="$(CoreClrProjectRoot)tools\dotnet-pgo\dotnet-pgo-pack.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.packages+')) and '$(PgoInstrument)' != 'true'">



    //
    // If "clr.nativeaotlibs" is present and NativeAOT is supported, add all of the src\*.csproj
    // files found under src\coreclr\nativeaot\...
    //
    // Ref:
    //
    //    [[
    //      l:\Git\github\dotnet\runtime $ where /r src\coreclr\nativeaot *.csproj | findstr /ir /c:"src\\[^\\]*\.csproj *$"
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\System.Private.CoreLib\src\System.Private.CoreLib.csproj
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\System.Private.DisabledReflection\src\System.Private.DisabledReflection.csproj
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\System.Private.Reflection.Execution\src\System.Private.Reflection.Execution.csproj
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\System.Private.StackTraceMetadata\src\System.Private.StackTraceMetadata.csproj
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\System.Private.TypeLoader\src\System.Private.TypeLoader.csproj
    //      l:\Git\github\dotnet\runtime\src\coreclr\nativeaot\Test.CoreLib\src\Test.CoreLib.csproj
    //    ]]
    //

    <ItemGroup Condition="$(_subset.Contains('+clr.nativeaotlibs+')) and '$(NativeAotSupported)' == 'true'">


        <ProjectToBuild
            Category="clr"
            Include="$(CoreClrProjectRoot)nativeaot\**\src\*.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+clr.nativeaotlibs+')) and '$(NativeAotSupported)' == 'true'">



    //
    // <InOriginal>
    // Mono sets.
    // </InOriginal>
    //
    ;



    <ItemGroup
        Condition="
                $(_subset.Contains('+mono.llvm+'))
            or
                $(_subset.Contains('+mono.aotcross+'))
            or
                '$(TargetOS)' == 'iOS'
            or
                '$(TargetOS)' == 'iOSSimulator'
            or
                '$(TargetOS)' == 'tvOS'
            or
                '$(TargetOS)' == 'tvOSSimulator'
            or
                '$(TargetOS)' == 'MacCatalyst'
            or
                '$(TargetOS)' == 'Android'
            or
                '$(TargetOS)' == 'Browser'
            or
                '$(TargetsLinuxBionic)' == 'true'
        "
    >


        <ProjectToBuild
            Category="mono"
            Include="$(MonoProjectRoot)llvm\llvm-init.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="<<llvm-init is needed>>">



    <ItemGroup Condition="$(_subset.Contains('+mono.packages+'))">


        <ProjectToBuild
            Category="mono"
            Pack="true"
            Include="$(MonoProjectRoot)nuget\mono-packages.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.packages+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.runtime+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(MonoProjectRoot)mono.proj"
            AdditionalProperties="
                %(AdditionalProperties);
                MonoMsCorDbi=$(_subset.Contains('+mono.mscordbi+'))
            "
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.runtime+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.aotcross+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(MonoProjectRoot)monoaotcross.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.aotcross+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.corelib+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(MonoProjectRoot)System.Private.CoreLib\System.Private.CoreLib.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.corelib+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.tools+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(CoreClrProjectRoot)tools\dotnet-pgo\dotnet-pgo.csproj;"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.tools+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.workloads+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(WorkloadsProjectRoot)\workloads.csproj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.workloads+'))">



    //
    // <InOriginal>
    // Host sets.
    // </InOriginal>
    //
    ;



    <ItemGroup Condition="$(_subset.Contains('+host.native+'))">



        <CorehostProjectToBuild
            SignPhase="Binaries"
            Include="$(SharedNativeRoot)corehost\corehost.proj"
        />



        <ProjectToBuild
            Category="host"
            Pack="true"
            Include="@(CorehostProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+host.native+'))">



    <ItemGroup Condition="$(_subset.Contains('+host.tools+'))">



        <ManagedProjectToBuild
            SignPhase="Binaries"
            Include="$(InstallerProjectRoot)managed\**\*.csproj"
        />



        <ProjectToBuild
            Category="host"
            Pack="true"
            BuildInParallel="true"
            Include="@(ManagedProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+host.tools+'))">



    <ItemGroup Condition="$(_subset.Contains('+host.pkg+')) and '$(PgoInstrument)' != 'true'">



        <PkgprojProjectToBuild
            SignPhase="MsiFiles"
            Include="$(InstallerProjectRoot)pkg\projects\host-packages.proj"
        />



        <ProjectToBuild
            Category="host"
            Pack="true"
            Include="@(PkgprojProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+host.pkg+')) and '$(PgoInstrument)' != 'true'">



    //
    // <InOriginal>
    // Libraries sets.
    // </InOriginal>
    //
    ;



    <ItemGroup Condition="$(_subset.Contains('+libs.native+'))">


        <ProjectToBuild
            Category="libs"
            Include="$(SharedNativeRoot)libs\build-native.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+libs.native+'))">



    <ItemGroup
        Condition="
                $(_subset.Contains('+libs.ref+'))
            or
                $(_subset.Contains('+libs.src+'))
            or $(_subset.Contains('+libs.sfx+'))
        "
    >


        <ProjectToBuild
            Category="libs"
            Condition="
                    '$(BuildTargetFramework)' == '$(NetCoreAppCurrent)'
                or
                    '$(BuildTargetFramework)' == ''
                or
                    '$(BuildAllConfigurations)' == 'true'
            "
            Include="$(LibrariesProjectRoot)sfx.proj"
        >


            <AdditionalProperties Condition="$(_subset.Contains('+libs.ref+'))">
                %(AdditionalProperties);
                RefOnly=true
            </AdditionalProperties>


        </ProjectToBuild>


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+libs.ref+')) or $(_subset.Contains('+libs.src+')) or $(_subset.Contains('+libs.sfx+'))">



    <ItemGroup
        Condition="
                $(_subset.Contains('+libs.ref+'))
            or
                $(_subset.Contains('+libs.src+'))
            or
                $(_subset.Contains('+libs.oob+'))
        "
    >


        <ProjectToBuild
            Category="libs"
            Include="$(LibrariesProjectRoot)oob.proj"
        >


            <AdditionalProperties Condition="$(_subset.Contains('+libs.ref+'))">
                %(AdditionalProperties);
                RefOnly=true
            </AdditionalProperties>


        </ProjectToBuild>


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+libs.ref+')) or $(_subset.Contains('+libs.src+')) or $(_subset.Contains('+libs.oob+'))">



    <ItemGroup Condition="$(_subset.Contains('+mono.wasmruntime+'))">


        <ProjectToBuild
            Category="mono"
            Include="$(MonoProjectRoot)wasm\wasm.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+mono.wasmruntime+'))">



    <ItemGroup Condition="$(_subset.Contains('+libs.pretest+'))">


        <ProjectToBuild
            Category="libs"
            Include="$(LibrariesProjectRoot)pretest.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+libs.pretest+'))">



    <ItemGroup Condition="$(_subset.Contains('+libs.tests+'))">


        <ProjectToBuild
            Category="libs"
            Test="true"
            Include="$(LibrariesProjectRoot)tests.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+libs.tests+'))">



    //
    // <InOriginal>
    //
    // Host.tests subset (consumes live built libraries assets so needs to come after
    // libraries).
    //
    // </InOriginal>
    //

    <ItemGroup Condition="$(_subset.Contains('+host.tests+'))">



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\Microsoft.NET.HostModel.Tests\AppHost.Bundle.Tests\AppHost.Bundle.Tests.csproj"
        />



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\Microsoft.NET.HostModel.Tests\Microsoft.NET.HostModel.AppHost.Tests\Microsoft.NET.HostModel.AppHost.Tests.csproj"
        />



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\Microsoft.NET.HostModel.Tests\Microsoft.NET.HostModel.Bundle.Tests\Microsoft.NET.HostModel.Bundle.Tests.csproj"
        />



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\Microsoft.NET.HostModel.Tests\Microsoft.NET.HostModel.ComHost.Tests\Microsoft.NET.HostModel.ComHost.Tests.csproj"
        />



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\HostActivation.Tests\HostActivation.Tests.csproj"
        />



        <ProjectToBuild
            Category="host"
            Test="true"
            BuildInParallel="true"
            Include="@(TestProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+host.tests+'))">



    //
    // <InOriginal>
    // Packs sets.
    // </InOriginal>
    //
    ;



    <Choose>


        <When Condition="$(_subset.Contains('+packs.product+'))">



            <ItemGroup Condition="'$(RuntimeFlavor)' != 'Mono'">



                <SharedFrameworkProjectToBuild
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\Microsoft.NETCore.App.Runtime.Composite.sfxproj"
                />



                <SharedFrameworkProjectToBuild
                    Include="$(InstallerProjectRoot)pkg\sfx\bundle\Microsoft.NETCore.App.Composite.Bundle.bundleproj"
                />


            </ItemGroup> // End of: <ItemGroup Condition="'$(RuntimeFlavor)' != 'Mono'">



            <ItemGroup Condition="'$(PgoInstrument)' != 'true'">



                <SharedFrameworkProjectToBuild
                    Condition="'$(BuildMonoAOTCrossCompilerOnly)' != 'true'"
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\Microsoft.NETCore.App.Ref.sfxproj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\Microsoft.NETCore.App.Host.sfxproj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' != 'Mono'"
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\Microsoft.NETCore.App.Crossgen2.sfxproj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\sfx\installers\dotnet-host.proj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\sfx\installers\dotnet-hostfxr.proj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\sfx\installers\dotnet-runtime-deps\*.proj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\archives\dotnet-nethost.proj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(MonoCrossAOTTargetOS)' != ''"
                    Pack="true"
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\monocrossaot.sfxproj"
                />



                <ProjectToBuild
                    Category="packs"
                    Condition="'$(NativeAotSupported)' == 'true' and '$(RuntimeFlavor)' != 'Mono'"
                    Include="$(InstallerProjectRoot)\pkg\projects\nativeaot-packages.proj"
                />


            </ItemGroup> // End of: <ItemGroup Condition="'$(PgoInstrument)' != 'true'">



            <ItemGroup>


                <SharedFrameworkProjectToBuild
                    Condition="'$(BuildMonoAOTCrossCompilerOnly)' != 'true'"
                    Include="$(InstallerProjectRoot)pkg\sfx\Microsoft.NETCore.App\Microsoft.NETCore.App.Runtime.sfxproj"
                />



                <SharedFrameworkProjectToBuild
                    Condition="'$(RuntimeFlavor)' == '$(PrimaryRuntimeFlavor)'"
                    Include="$(InstallerProjectRoot)pkg\sfx\bundle\Microsoft.NETCore.App.Bundle.bundleproj"
                />



                <ProjectToBuild
                    Category="packs"
                    Include="@(SharedFrameworkProjectToBuild)"
                />


            </ItemGroup>


        </When> // End of: <When Condition="$(_subset.Contains('+packs.product+'))">


    </Choose>



    <ItemGroup Condition="$(_subset.Contains('+packs.installers+')) and '$(PgoInstrument)' != 'true'">



        <InstallerProjectToBuild
            Include="$(InstallerProjectRoot)pkg\sfx\installers.proj"
        />



        <ProjectToBuild
            Category="packs"
            Include="@(InstallerProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+packs.installers+')) and '$(PgoInstrument)' != 'true'">



    <ItemGroup Condition="$(_subset.Contains('+packs.tests+')) and '$(PgoInstrument)' != 'true'">



        <TestProjectToBuild
            Include="$(InstallerProjectRoot)tests\Microsoft.DotNet.CoreSetup.Packaging.Tests\Microsoft.DotNet.CoreSetup.Packaging.Tests.csproj"
        />



        <ProjectToBuild
            Category="packs"
            Test="true"
            BuildInParallel="true"
            Include="@(TestProjectToBuild)"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+packs.tests+')) and '$(PgoInstrument)' != 'true'">



    <ItemGroup Condition="$(_subset.Contains('+publish+'))">


        <ProjectToBuild
            Category="publish"
            Pack="true"
            Include="$(InstallerProjectRoot)prepare-artifacts.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+publish+'))">



    //
    // <InOriginal>
    // Utility.
    // </InOriginal>
    //
    ;



    <ItemGroup Condition="$(_subset.Contains('+regeneratedownloadtable+'))">


        <ProjectToBuild
            Pack="true"
            Include="$(RepositoryEngineeringDir)regenerate-download-table.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('+regeneratedownloadtable+'))">



    <ItemGroup Condition="$(_subset.Contains('regeneratethirdpartynotices'))">


        <ProjectToBuild
            Pack="false"
            BuildInParallel="false"
            Include="$(RepositoryEngineeringDir)regenerate-third-party-notices.proj"
        />


    </ItemGroup> // End of: <ItemGroup Condition="$(_subset.Contains('regeneratethirdpartynotices'))">



    //
    // <InOriginal>
    // Set default configurations.
    // </InOriginal>
    //

    <ItemGroup>


        <ProjectToBuild Update="@(ProjectToBuild)">



            <AdditionalProperties Condition="'%(ProjectToBuild.Category)' == 'clr' and '$(CoreCLRConfiguration)' != ''">
                %(AdditionalProperties);
                Configuration=$(CoreCLRConfiguration)
            </AdditionalProperties>



            <AdditionalProperties Condition="'%(ProjectToBuild.Category)' == 'mono' and '$(MonoConfiguration)' != ''">
                %(AdditionalProperties);
                Configuration=$(MonoConfiguration)
            </AdditionalProperties>



            <AdditionalProperties Condition="'%(ProjectToBuild.Category)' == 'libs' and '$(LibrariesConfiguration)' != ''">
                %(AdditionalProperties);
                Configuration=$(LibrariesConfiguration)
            </AdditionalProperties>



            //
            // <InOriginal>
            // Propagate host configuration for libs build since live host is used for testing.
            // </InOriginal>
            //

            <AdditionalProperties Condition="'%(ProjectToBuild.Category)' == 'libs' and '$(HostConfiguration)' != ''">
                %(AdditionalProperties);
                HostConfiguration=$(HostConfiguration)
            </AdditionalProperties>



            <AdditionalProperties Condition="'%(ProjectToBuild.Category)' == 'host' and '$(HostConfiguration)' != ''">
                %(AdditionalProperties);
                Configuration=$(HostConfiguration)
            </AdditionalProperties>


        </ProjectToBuild> // End of: <ProjectToBuild Update="@(ProjectToBuild)">


    </ItemGroup>


</Project>





{l:\Git\github\dotnet\runtime\eng\SubsetValidation.targets}


    //
    // During build.cmd, this file is reached via the following sequence:
    //
    //      {l:\Git\github\dotnet\runtime\eng\SubsetValidation.targets}
    //      {l:\Git\github\dotnet\runtime\Build.proj}
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //

<Project
    InitialTargets="
        FindInvalidSpecifiedSubsetNames;
        ReportValidSubsetList
    "
>


    <Target Name="FindInvalidSpecifiedSubsetNames">



        <ItemGroup>


            //
            // Extract the [+-;]-delimited components of the ambient Subset setting.
            //
            // Notes:
            //
            //    .
            //      The Subset setting can be empty, in which case the validation below will succeed (by
            //      definition) and processing along the following stack
            //
            //          {l:\Git\github\dotnet\runtime\eng\Subsets.props}
            //          {l:\Git\github\dotnet\runtime\Directory.Build.props}
            //          ...
            //
            //      will use default subsets to fill the $(_subset) collection which drives the build.
            //

            <SpecifiedSubsetName
                Include="
                    $(
                        [MSBuild]::Unescape(
                            $(
                              Subset
                                .Replace('+', ';')
                                .Replace('-', ';')
                            )
                        )
                    )
                "
            />



            //
            // <InOriginal>
            // Note that MSBuild Exclude is case-insensitive, which matches intended behavior.
            // </InOriginal>
            //
            // Fill InvalidSpecifiedSubsetName with the list of of all [+-;]-delimited components of
            // the ambient Subset setting (if any) which are NOT also listed in the SubsetName "allow
            // list" that was constructed along the following stack:
            //
            //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
            //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
            //      ...
            //

            <InvalidSpecifiedSubsetName
                Include="@(SpecifiedSubsetName)"
                Exclude="@(SubsetName)"
            />


        </ItemGroup>



        <PropertyGroup>



            //
            // Set the UserRequestedHelp property if and only if a subset named "help" appears among
            // the zero-or-more requested subsets that were not found in the SubsetName "allow list"
            // (since this is taken as a sign that the user is trying to convince this file to print a
            // description of all allowed subsets to the console).
            //

            <UserRequestedHelp Condition="'%(InvalidSpecifiedSubsetName.Identity)' == 'help'">
                true
            </UserRequestedHelp>


        </PropertyGroup>


    </Target> // End of: <Target Name="FindInvalidSpecifiedSubsetNames">



    <Target Name="ReportValidSubsetList"
        Condition="'@(InvalidSpecifiedSubsetName)' != ''"
    >



        //
        // Control reaches this point if and only if one-or-more user requested subsets were not
        // found in the SubsetName "allow list".
        //
        // In all such cases, print an error message along with a description of all allowed
        // subsets.
        //
        // If the user requested a subset named "help", then the UserRequestedHelp property is set,
        // and this is taken as a sign that the user is trying to convince this file to print a
        // description of all allowed subsets to the console (and the console output is adjusted
        // accordingly).
        //
        ;



        //
        // As defined along the following stack
        //
        //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
        //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
        //      ...
        //
        // each entry in the SubsetName "allow list" contains the core name of the subset (i.e.,
        // the %(Identity)), plus a required "Description" property, plus an optional "OnDemand"
        // property.
        //
        // Update each entry with a new "Text" property which contains a combined rendering of the
        // %(Identity), "Description", and "OnDemand" settings for that entry.
        //

        <ItemGroup>



            <SubsetName
                Text="- %(Identity)"
            />



            <SubsetName
                Condition="'%(SubsetName.OnDemand)' == 'true'"
                Text="%(Text) [only runs on demand]"
            />



            <SubsetName
                Text="%(Text)%0A    %(Description)"
            />


        </ItemGroup>



        //
        // Output a block of text which joins all of the "Text" properties constructed above into a
        // newline-delimited sequence which combines to represent a full description of all of the
        // entries in the SubsetName "allow list".
        //

        <Message
            Importance="High"
            Text="%0AAccepted Subset values:%0A@(SubsetName->'%(Text)', '%0A')%0A"
        />



        <Error
            Condition="'$(UserRequestedHelp)' != 'true'"
            Text="Subset not recognized: @(InvalidSpecifiedSubsetName, ' ')"
        />



        <Error
            Condition="'$(UserRequestedHelp)' == 'true'"
            Text="This is not an error. These are the available subsets. You can choose one or none at all for a full build."
        />


    </Target> // End of: <Target Name="ReportValidSubsetList" Condition="'@(InvalidSpecifiedSubsetName)' != ''">


</Project>





{l:\Git\github\dotnet\runtime\src\coreclr\runtime.proj}


    //
    // During build.cmd, this file is reached via the following sequence
    //
    //      {l:\Git\github\dotnet\runtime\src\coreclr\runtime.proj}
    //      ...
    //      [[ build all of the ProjectToBuild items that were bulk-added to the ProjectReference group ]]
    //      ...
    //      {l:\Git\github\Microsoft\MSBuildSdks\src\Traversal\Sdk\Sdk.targets}
    //      {l:\Git\github\dotnet\runtime\Build.proj}
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //
    // in any situation where the set of requested subsets causes the logic at
    //
    //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
    //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
    //      ...
    //
    // to add one or more instances of src\coreclr\runtime.proj to the ProjectToBuild set.
    // As shown in the {l:\Git\github\dotnet\runtime\eng\Subsets.props} listing, most/all
    // CoreCLR-related subsets will force this to occur (e.g., clr.native, clr.runtime, etc).
    //
    // Notes:
    //
    //    .
    //      See #NATURE_OF_NOTARGETS_SDK for information about the "NoTargets" machinery being used
    //      here.
    //

<Project Sdk="Microsoft.Build.NoTargets">



    <PropertyGroup>


        <NativeBuildPartitionPropertiesToRemove>
            ClrFullNativeBuild;
            ClrRuntimeSubset;
            ClrJitSubset;
            ClrPalTestsSubset;
            ClrAllJitsSubset;
            ClrILToolsSubset;
            ClrNativeAotSubset;
            ClrSpmiSubset;
            ClrCrossComponentsSubset;
            HostArchitecture;
            PgoInstrument;
            NativeOptimizationDataSupported;
            CMakeArgs
        </NativeBuildPartitionPropertiesToRemove>


    </PropertyGroup>



    <ItemGroup>


        <ProjectReference
            Include="runtime-prereqs.proj"
            GlobalPropertiesToRemove="$(NativeBuildPartitionPropertiesToRemove)"
        />


    </ItemGroup>



    <Import Project="$(RepositoryEngineeringDir)nativepgo.targets" />



    <Target Name="BuildRuntime"

        BeforeTargets="
            Build
        "

        DependsOnTargets="
            GetPgoDataPackagePath
        "
    >



        <ItemGroup>



            <_CoreClrBuildArg
                Condition="'$(TargetArchitecture)' != ''"
                Include="-$(TargetArchitecture)"
            />



            <_CoreClrBuildArg
                Condition="'$(CMakeArgs)' != ''"
                Include="-cmakeargs &quot;$(CMakeArgs)&quot;"
            />



            <_CoreClrBuildArg
                Include="-$(Configuration.ToLower())"
            />



            <_CoreClrBuildArg
                Include="$(Compiler)"
            />



            <_CoreClrBuildArg
                Condition="'$(ConfigureOnly)' == 'true'"
                Include="-configureonly"
            />



            <_CoreClrBuildArg
                Condition="'$(ContinuousIntegrationBuild)' == 'true'"
                Include="-ci"
            />



            <_CoreClrBuildArg
                Condition="'$(CrossBuild)' == 'true'"
                Include="-cross"
            />



            <_CoreClrBuildArg
                Condition="'$(PortableBuild)' != 'true'"
                Include="-portablebuild=false"
            />



            <_CoreClrBuildArg
                Condition="'$(KeepNativeSymbols)' != 'false'"
                Include="-keepnativesymbols"
            />



            <_CoreClrBuildArg
                Include="-os $(TargetOS)"
            />



            <_CoreClrBuildArg
                Condition="

                        $([MSBuild]::IsOsPlatform(Windows))

                    and

                        (
                                '$(TargetArchitecture)' == 'x86'
                            or
                                '$(TargetArchitecture)' == 'x64'
                        )

                    and

                        '$(Configuration)' == 'Release'

                    and

                        '$(ClrRuntimeSubset)' == 'true'

                    and

                        '$(NativeOptimizationDataSupported)' == 'true'

                    and

                        '$(PgoInstrument)' != 'true'
                "
                Include="-enforcepgo"
            />



            <_CoreClrBuildArg
                Condition="'$(Ninja)' == 'true' and !$([MSBuild]::IsOsPlatform(Windows))"
                Include="-ninja"
            />



            <_CoreClrBuildArg
                Condition="'$(Ninja)' == 'false' and $([MSBuild]::IsOsPlatform(Windows))"
                Include="-msbuild"
            />



            <_CoreClrBuildArg
                Condition="'$(PgoInstrument)' == 'true'"
                Include="-pgoinstrument"
            />



            <_CoreClrBuildArg
                Condition="
                        '$(NativeOptimizationDataSupported)' == 'true'
                    and
                        '$(NoPgoOptimize)' != 'true'
                    and
                        '$(PgoInstrument)' != 'true'
                "
                Include="-pgodatapath &quot;$(PgoPackagePath)&quot;"
            />



            <_CoreClrBuildArg
                Condition="'$(HostArchitecture)' != ''"
                Include="-hostarch $(HostArchitecture)"
            />


        </ItemGroup>



        //
        // If the current build is not a full native build, then translate the incoming set of
        // Clr*Subset properties into a corresponding set of "-component" switches which combine to
        // describe the selected subsets.
        //
        // Notes:
        //
        //    .
        //      Across the current listings, the ClrFullNativeBuild property is set to true if and only
        //      if the "clr.native" subset is targeted by the current build.
        //

        <ItemGroup Condition="'$(ClrFullNativeBuild)' != 'true'">



            <_CoreClrBuildArg
                Condition="'$(ClrHostsSubset)' == 'true'"
                Include="-component hosts"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrRuntimeSubset)' == 'true'"
                Include="-component runtime"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrJitSubset)' == 'true'"
                Include="-component jit"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrPalTestsSubset)' == 'true'"
                Include="-component paltests"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrAllJitsSubset)' == 'true'"
                Include="-component alljits"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrILToolsSubset)' == 'true'"
                Include="-component iltools"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrNativeAotSubset)' == 'true'"
                Include="-component nativeaot"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrSpmiSubset)' == 'true'"
                Include="-component spmi"
            />



            <_CoreClrBuildArg
                Condition="'$(ClrCrossComponentsSubset)' == 'true'"
                Include="-component crosscomponents"
            />


        </ItemGroup> // End of: <ItemGroup Condition="'$(ClrFullNativeBuild)' != 'true'">



        <PropertyGroup>



            <_CoreClrBuildScript Condition="$([MSBuild]::IsOsPlatform(Windows))">
                build-runtime.cmd
            </_CoreClrBuildScript>



            <_CoreClrBuildScript Condition="!$([MSBuild]::IsOsPlatform(Windows))">
                build-runtime.sh
            </_CoreClrBuildScript>


        </PropertyGroup>



        //
        // Show the path to the selected script (which sits alongside this src\coreclr\runtime.proj
        // file) along with a space-delimited concatenation of the _CoreClrBuildArg collection
        // members that were prepared above.
        //

        <Message
            Importance="High"
            Text="Executing &quot;$(MSBuildThisFileDirectory)$(_CoreClrBuildScript)&quot; @(_CoreClrBuildArg->'%(Identity)',' ')"
        />



        //
        // <InOriginal>
        //
        // Use IgnoreStandardErrorWarningFormat because Arcade sets WarnAsError and there's an
        // existing warning in the native build.
        //
        // </InOriginal>
        //
        // Invoke the selected build-runtime.* script (which sits alongside this
        // src\coreclr\runtime.proj file), passing a space-delimited concatenation of the
        // _CoreClrBuildArg collection members that were prepared above.
        //

        <Exec
            IgnoreStandardErrorWarningFormat="true"
            Command="&quot;$(MSBuildThisFileDirectory)$(_CoreClrBuildScript)&quot; @(_CoreClrBuildArg->'%(Identity)',' ')"
        />


    </Target> // End of: <Target Name="BuildRuntime" DependsOnTargets="GetPgoDataPackagePath" BeforeTargets="Build">


</Project>





{l:\Git\github\dotnet\runtime\src\coreclr\runtime-prereqs.proj}


<Project>



    <Import Project="Sdk.props"
        Sdk="Microsoft.Build.NoTargets"
    />



    <PropertyGroup>



        <NativeVersionFile Condition="$([MSBuild]::IsOsPlatform(Windows))">
            $(ArtifactsObjDir)_version.h
        </NativeVersionFile>



        <NativeVersionFile Condition="!$([MSBuild]::IsOsPlatform(Windows))">
            $(ArtifactsObjDir)_version.c
        </NativeVersionFile>



        <RuntimeVersionFile>
            $(ArtifactsObjDir)runtime_version.h
        </RuntimeVersionFile>



        <NativeSourceLinkFile>
            $(ArtifactsObjDir)native.sourcelink.json
        </NativeSourceLinkFile>



        <VerifySourceLinkFileExists>
            false
        </VerifySourceLinkFileExists>



        <VerifySourceLinkFileExists Condition="'$(ContinuousIntegrationBuild)' == 'true' AND '$(EnableSourceControlManagerQueries)' == 'true'">
            true
        </VerifySourceLinkFileExists>



        <AssemblyName>
            .NET Runtime
        </AssemblyName>


    </PropertyGroup>



    <Import Project="$(RepositoryEngineeringDir)versioning.targets" />



    <Import Project="$(RepositoryEngineeringDir)nativepgo.targets" />




    <Target Name="BuildPrereqs"

        BeforeTargets="
            Build
        "

        DependsOnTargets="
            GenerateRuntimeVersionFile;
            GenerateNativeSourcelinkFile;
            OutputPgoPathForCI
        "
    />



    <Import Project="Sdk.targets"
        Sdk="Microsoft.Build.NoTargets"
    />



    //
    // <InOriginal>
    //
    // This is relatively ugly.
    //
    // The NoTargets SDK sets DebugType=None, but that makes it such that the sourcelink
    // targets don't run, and we wouldn't generate the sourcelink file for native compilation.
    //
    // It would be better if we could call the target directly and have it generate the file,
    // but it's guarded by this property anyway...
    //
    // </InOriginal>
    //

    <PropertyGroup>
        <DebugType>Portable</DebugType>
    </PropertyGroup>


</Project>






{l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}


    //
    // During build.cmd, this file is reached via the following sequence
    //
    //      {l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}
    //      ...
    //      [[ invocation via the msbuild "Exec" target ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\src\coreclr\runtime.proj}
    //      ...
    //      [[ build all of the ProjectToBuild items that were bulk-added to the ProjectReference group ]]
    //      ...
    //      {l:\Git\github\Microsoft\MSBuildSdks\src\Traversal\Sdk\Sdk.targets}
    //      {l:\Git\github\dotnet\runtime\Build.proj}
    //      {l:\Git\github\dotnet\arcade\src\Microsoft.DotNet.Arcade.Sdk\tools\Build.proj}
    //      ...
    //      [[ invoke "dotnet msbuild" ]]
    //      ...
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild-Core
    //      {l:\Git\github\dotnet\runtime\eng\common\tools.ps1}::MSBuild
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::Build
    //      {l:\Git\github\dotnet\runtime\eng\common\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\eng\build.ps1}::{TopLevelCode}
    //      {l:\Git\github\dotnet\runtime\build.cmd}::{TopLevelCode}
    //      ...
    //
    // in any situation where the set of requested subsets causes the logic at
    //
    //      {l:\Git\github\dotnet\runtime\eng\Subsets.props}
    //      {l:\Git\github\dotnet\runtime\Directory.Build.props}
    //      ...
    //
    // to add one or more instances of src\coreclr\runtime.proj to the ProjectToBuild set.
    // As shown in the {l:\Git\github\dotnet\runtime\eng\Subsets.props} listing, most/all
    // CoreCLR-related subsets will force this to occur (e.g., clr.native, clr.runtime, etc).
    //

{


    @if not defined _echo @echo off



    setlocal EnableDelayedExpansion EnableExtensions



    //
    // <InOriginal>
    //
    // Define a prefix for most output progress messages that come from this script.
    //
    // That makes it easier to see where these are coming from.
    //
    // Note that there is a trailing space here.
    //
    // </InOriginal>
    //

    set "__MsgPrefix=BUILD: "



    echo %__MsgPrefix%Starting Build at %TIME%



    set __ThisScriptFull="%~f0"


    //
    // <InOriginal>
    //
    // Note that the msbuild project files (specifically, dir.proj) will use the following
    // variables, if set:
    //
    //      __TargetArch
    //
    //          Default: x64
    //
    //      __BuildType
    //
    //          Default: Debug
    //
    //      __TargetOS
    //
    //          Default: windows
    //
    //      __ProjectDir
    //
    //          Default: Directory of the dir.props file.
    //
    //      __RepoRootDir
    //
    //          Default: Directory two levels above the dir.props file.
    //
    //      __RootBinDir
    //
    //          Default: %__RepoRootDir%\artifacts\
    //
    //      __BinDir
    //
    //          Default: %__RootBinDir%\obj\coreclr\%__TargetOS%.%__TargetArch.%__BuildType%\
    //
    //      __IntermediatesDir
    //
    //          Default: <no default is listed in the current build-runtime.cmd file>
    //
    //      __PackagesBinDir
    //
    //          Default: %__BinDir%\.nuget
    //
    // Thus, these variables are not simply internal to this script!
    //
    // </InOriginal>
    //
    ;



    //
    // <InOriginal>
    // Set the default arguments for build.
    // </InOriginal>
    //
    ;



    set __TargetArch=x64



    set __BuildType=Debug



    set __TargetOS=windows



    //
    // <InOriginal>
    // Set the various build properties here so that CMake and MSBuild can pick them up.
    // </InOriginal>
    //
    ;



    //
    // <InOriginal>
    // Remove trailing slash.
    // </InOriginal>
    //

    set "__ProjectDir=%~dp0"

    if %__ProjectDir:~-1%==\ set "__ProjectDir=%__ProjectDir:~0,-1%"



    set "__RepoRootDir=%__ProjectDir%\..\.."



    set "__ProjectFilesDir=%__ProjectDir%"



    set "__RootBinDir=%__RepoRootDir%\artifacts"



    set __BuildAll=



    set __TargetArchX64=0

    set __TargetArchX86=0

    set __TargetArchArm=0

    set __TargetArchArm64=0



    set __BuildTypeDebug=0

    set __BuildTypeChecked=0

    set __BuildTypeRelease=0



    set __PgoInstrument=0



    set __PgoOptimize=0



    set __EnforcePgo=0



    set __ConsoleLoggingParameters=/clp:ForceNoAlign;Summary



    //
    // <InOriginal>
    //
    // __PassThroughArgs is a set of things that will be passed through to nested calls to
    // build.cmd when using "all".
    //
    // </InOriginal>
    //

    set __PassThroughArgs=



    set "__remainingArgs=%*"



    //
    // <InOriginal>
    // __UnprocessedBuildArgs are args that we pass to msbuild (e.g., /p:OfficialBuildId=value).
    // </InOriginal>
    //

    set __UnprocessedBuildArgs=



    set __BuildNative=1



    set __RestoreOptData=1



    set __HostArch=



    set __HostArch2=



    set __PgoOptDataPath=



    set __CMakeArgs=



    set __Ninja=1



    set __RequestedBuildComponents=



    :Arg_Loop



        if "%1" == "" (
            goto ArgsDone
        )



        set "__remainingArgs=!__remainingArgs:*%1=!"



        if /i "%1" == "/?" ( goto :Usage )

        if /i "%1" == "-?" ( goto :Usage )

        if /i "%1" == "/h" ( goto :Usage )

        if /i "%1" == "-h" ( goto :Usage )

        if /i "%1" == "/help" ( goto :Usage )

        if /i "%1" == "-help" ( goto :Usage )

        if /i "%1" == "--help" ( goto :Usage )



        if /i "%1" == "-all" (
            set __BuildAll=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-x64" (
            set __TargetArchX64=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-x86" (
            set __TargetArchX86=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-arm" (
            set __TargetArchArm=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-arm64" (
            set __TargetArchArm64=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-debug" (
            set __BuildTypeDebug=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-checked" (
            set __BuildTypeChecked=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-release" (
            set __BuildTypeRelease=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-ci" (
            set __ArcadeScriptArgs="-ci"
            set __ErrMsgPrefix=##vso[task.logissue type=error]
            shift
            goto Arg_Loop
        )



        //
        // <InOriginal>
        //
        // Todo: These are deprecated; remove them eventually.
        //
        // Don't add more of these; use the "-" syntax instead.
        //
        // </InOriginal>
        //
        ;



        if /i "%1" == "all" (
            set __BuildAll=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "x64" (
            set __TargetArchX64=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "x86" (
            set __TargetArchX86=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "arm" (
            set __TargetArchArm=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "arm64" (
            set __TargetArchArm64=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "debug" (
            set __BuildTypeDebug=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "checked" (
            set __BuildTypeChecked=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "release" (
            set __BuildTypeRelease=1
            shift
            goto Arg_Loop
        )



        //
        // <InOriginal>
        // Explicitly block -Rebuild.
        // </InOriginal>
        //
        ;



        if /i "%1" == "Rebuild" (
            echo "ERROR: 'Rebuild' is not supported.  Please remove it."
            goto :Usage
        )



        if /i "%1" == "-Rebuild" (
            echo "ERROR: 'Rebuild' is not supported.  Please remove it."
            goto :Usage
        )



        //
        // <InOriginal>
        //
        // All arguments after this point will be passed through directly to build.cmd on nested
        // invocations using the "all" argument, and must be added to the __PassThroughArgs
        // variable.
        //
        // </InOriginal>
        //

        if [!__PassThroughArgs!]==[] (
            set "__PassThroughArgs=%1"

        ) else (
            set "__PassThroughArgs=%__PassThroughArgs% %1"
        )



        if /i "%1" == "-hostarch" (
            set __HostArch=%2
            shift
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-os" (
            set __TargetOS=%2
            shift
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-cmakeargs" (
            set __CMakeArgs=%2 %__CMakeArgs%
            set __remainingArgs="!__remainingArgs:*%2=!"
            shift
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-configureonly" (
            set __ConfigureOnly=1
            set __BuildNative=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-skipconfigure" (
            set __SkipConfigure=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-skipnative" (
            set __BuildNative=0
            shift
            goto Arg_Loop
        )



        //
        // <InOriginal>
        // -ninja is a no-op option since Ninja is now the default generator on Windows.
        // </InOriginal>
        //

        if /i "%1" == "-ninja" (
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-msbuild" (
            set __Ninja=0
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-pgoinstrument" (
            set __PgoInstrument=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-enforcepgo" (
            set __EnforcePgo=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-pgodatapath" (
            set __PgoOptDataPath=%2
            set __PgoOptimize=1
            shift
            shift
            goto Arg_Loop
        )



        if /i "%1" == "-component" (
            set __RequestedBuildComponents=%__RequestedBuildComponents%-%2
            set "__remainingArgs=!__remainingArgs:*%2=!"
            shift
            shift
            goto Arg_Loop
        )



        //
        // <InOriginal>
        //
        // Todo: These are deprecated; remove them eventually.
        //
        // Don't add more of these; use the "-" syntax instead.
        //
        // </InOriginal>
        //
        ;



        if /i "%1" == "configureonly" (
            set __ConfigureOnly=1
            set __BuildNative=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "skipconfigure" (
            set __SkipConfigure=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "skipnative" (
            set __BuildNative=0
            shift
            goto Arg_Loop
        )



        if /i "%1" == "pgoinstrument" (
            set __PgoInstrument=1
            shift
            goto Arg_Loop
        )



        if /i "%1" == "enforcepgo" (
            set __EnforcePgo=1
            shift
            goto Arg_Loop
        )



        //
        // The current argument doesn't match any of the supported switch names.  Add it to the
        // unprocessed argument set and move to the next argument.
        //

        set "__UnprocessedBuildArgs=!__UnprocessedBuildArgs! %1"

        shift

        goto Arg_Loop



    :ArgsDone



    //
    // <InOriginal>
    // Initialize VS environment.
    // </InOriginal>
    //
    ;



    call %__RepoRootDir%\eng\native\init-vs-env.cmd



    if NOT '%ERRORLEVEL%' == '0' (
        goto :ExitWithError
    )



    if defined VCINSTALLDIR (
        set "__VCToolsRoot=%VCINSTALLDIR%Auxiliary\Build"
    )



    if defined __BuildAll (
        goto :BuildAll
    )

    goto :BuildCurrentConfig



    //
    // <InOriginal>
    // Handle the "all" case.
    // </InOriginal>
    //

    :BuildAll



        set __TargetArchList=



        set /A __TotalSpecifiedTargetArch=(
                __TargetArchX64
            +
                __TargetArchX86
            +
                __TargetArchArm
            +
                __TargetArchArm64
        )



        //
        // <InOriginal>
        // Nothing specified means we want to build all architectures.
        // </InOriginal>
        //

        if %__TotalSpecifiedTargetArch% EQU 0 (
            set __TargetArchList=x64 x86 arm arm64
        )



        //
        // <InOriginal>
        // Otherwise, add all the specified architectures to the list.
        // </InOriginal>
        //

        if %__TargetArchX64%==1     ( set __TargetArchList=%__TargetArchList% x64 )

        if %__TargetArchX86%==1     ( set __TargetArchList=%__TargetArchList% x86 )

        if %__TargetArchArm%==1     ( set __TargetArchList=%__TargetArchList% arm )

        if %__TargetArchArm64%==1   ( set __TargetArchList=%__TargetArchList% arm64 )



        set __BuildTypeList=



        set /A __TotalSpecifiedBuildType=(
                __BuildTypeDebug
            +
                __BuildTypeChecked
            +
                __BuildTypeRelease
        )



        //
        // <InOriginal>
        // Nothing specified means we want to build all build types.
        // </InOriginal>
        //

        if %__TotalSpecifiedBuildType% EQU 0 (
            set __BuildTypeList=Debug Checked Release
        )



        //
        // Otherwise, add all the specified build types to the list.
        //

        if %__BuildTypeDebug%==1    ( set __BuildTypeList=%__BuildTypeList% Debug )

        if %__BuildTypeChecked%==1  ( set __BuildTypeList=%__BuildTypeList% Checked )

        if %__BuildTypeRelease%==1  ( set __BuildTypeList=%__BuildTypeList% Release )



        //
        // <InOriginal>
        //
        // Create a temporary file to collect build results.
        //
        // We always build all flavors specified, and report a summary of the results at the end.
        //
        // </InOriginal>
        //
        ;



        set __BuildResultFile=%TEMP%\build-all-summary-%RANDOM%.txt



        if exist %__BuildResultFile% (
            del /f /q %__BuildResultFile%
        )



        set __AllBuildSuccess=true



        for %%i in (%__TargetArchList%) do (

            for %%j in (%__BuildTypeList%) do (

                call :BuildOne %%i %%j
            )
        )



        if %__AllBuildSuccess%==true (
            echo %__MsgPrefix%All builds succeeded!
            exit /b 0
        )



        echo %__MsgPrefix%Builds failed:

        type %__BuildResultFile%

        del /f /q %__BuildResultFile%

        goto ExitWithError



        //
        // %1 - Target architecture (x86, amd64, arm, or, arm64)
        // %2 - Targeted build type (Debug, Checked, or Release)
        //
        // This function carries out the requested build by recursively invoking the current
        // script.
        //

        :BuildOne



            set __TargetArch=%1



            set __BuildType=%2



            set __NextCmd=call %__ThisScriptFull% %__TargetArch% %__BuildType% %__PassThroughArgs%



            echo %__MsgPrefix%Invoking: %__NextCmd%



            %__NextCmd%



            if not !errorlevel! == 0 (
                echo %__MsgPrefix%    %__TargetArch% %__BuildType% %__PassThroughArgs% >> %__BuildResultFile%
                set __AllBuildSuccess=false
            )



            exit /b 0



    //
    // Handle the non-"all" case (i.e., the case where a specific build has been requested as
    // opposed to an aggregate "all" request).
    //

    :BuildCurrentConfig



        set /A __TotalSpecifiedTargetArch=(
                __TargetArchX64
            +
                __TargetArchX86
            +
                __TargetArchArm
            +
                __TargetArchArm64
        )



        if %__TotalSpecifiedTargetArch% GTR 1 (
            echo Error: more than one build architecture specified, but "all" not specified.
            goto Usage
        )



        set __ProcessorArch=%PROCESSOR_ARCHITEW6432%



        if "%__ProcessorArch%"=="" (
            set __ProcessorArch=%PROCESSOR_ARCHITECTURE%
        )



        if %__TargetArchX64%==1     ( set __TargetArch=x64 )

        if %__TargetArchX86%==1     ( set __TargetArch=x86 )

        if %__TargetArchArm%==1     ( set __TargetArch=arm )

        if %__TargetArchArm64%==1   ( set __TargetArch=arm64 )



        if "%__HostArch%" == "" (
            set __HostArch=%__TargetArch%
        )



        set /A __TotalSpecifiedBuildType=(
                __BuildTypeDebug
            +
                __BuildTypeChecked
            +
                __BuildTypeRelease
        )



        if %__TotalSpecifiedBuildType% GTR 1 (
            echo Error: more than one build type specified, but "all" not specified.
            goto Usage
        )



        if %__BuildTypeDebug%==1    ( set __BuildType=Debug )

        if %__BuildTypeChecked%==1  ( set __BuildType=Checked )

        if %__BuildTypeRelease%==1  ( set __BuildType=Release )



        if %__EnforcePgo%==1 (



            if %__TargetArchArm%==1 (
                echo NOTICE: enforcepgo does nothing on arm architecture
                set __EnforcePgo=0
            )



            if %__TargetArchArm64%==1 (
                echo NOTICE: enforcepgo does nothing on arm64 architecture
                set __EnforcePgo=0
            )


        ) // End of: if %__EnforcePgo%==1



        //
        // <InOriginal>
        //
        // PGO optimization is only applied to release builds (see pgosupport.cmake).
        //
        // Disable PGO by default if not building release.
        //
        // </InOriginal>
        //

        if NOT "%__BuildType%"=="Release" (
            set __PgoOptimize=0
        )



        set "__BinDir=%__RootBinDir%\bin\coreclr\%__TargetOS%.%__TargetArch%.%__BuildType%"



        set "__IntermediatesDir=%__RootBinDir%\obj\coreclr\%__TargetOS%.%__TargetArch%.%__BuildType%"



        set "__LogsDir=%__RootBinDir%\log\!__BuildType!"



        set "__MsbuildDebugLogsDir=%__LogsDir%\MsbuildDebugLogs"



        set "__ArtifactsIntermediatesDir=%__RepoRootDir%\artifacts\obj\coreclr\"



        if "%__Ninja%"=="0" (
            set "__IntermediatesDir=%__IntermediatesDir%\ide"
        )



        set "__PackagesBinDir=%__BinDir%\.nuget"



        if NOT "%__HostArch%" == "%__TargetArch%" (



            set __BinDir=%__BinDir%\%__HostArch%



            set __IntermediatesDir=%__IntermediatesDir%\%__HostArch%


        ) // End of: if NOT "%__HostArch%" == "%__TargetArch%"



        //
        // <InOriginal>
        // Generate path to be set for CMAKE_INSTALL_PREFIX to contain forward slash.
        // </InOriginal>
        //
        ;



        set "__CMakeBinDir=%__BinDir%"



        set "__CMakeBinDir=%__CMakeBinDir:\=/%"



        if not exist "%__BinDir%" (
            md "%__BinDir%"
        )



        if not exist "%__IntermediatesDir%" (
            md "%__IntermediatesDir%"
        )



        if not exist "%__LogsDir%" (
            md "%__LogsDir%"
        )



        if not exist "%__MsbuildDebugLogsDir%" (
            md "%__MsbuildDebugLogsDir%"
        )



        //
        // <InOriginal>
        // Set up the directory for MSBuild debug logs.
        // </InOriginal>
        //

        set MSBUILDDEBUGPATH=%__MsbuildDebugLogsDir%



        echo %__MsgPrefix%Commencing CoreCLR product build



        echo %__MsgPrefix%Checking prerequisites



        if %__BuildNative%==0 (
            goto :SkipLocateCMake
        )



        //
        // <InOriginal>
        // Eval the output from set-cmake-path.ps1.
        // </InOriginal>
        //

        for /f "delims=" %%a in (
            '
                powershell
                    -NoProfile
                    -ExecutionPolicy ByPass
                    "& ""%__RepoRootDir%\eng\native\set-cmake-path.ps1"""
            '
          )
            do (

            %%a
        )



        echo %__MsgPrefix%Using CMake from !CMakePath!



    :SkipLocateCMake



        //
        // <InOriginal>
        //
        // NumberOfCores is an WMI property providing number of physical cores on machine.
        //
        // It is used to set optimal level of CL parallelism during native build step.
        //
        // </InOriginal>
        //

        if not defined NumberOfCores (



            //
            // <InOriginal>
            // Determine number of physical processor cores available on machine.
            // </InOriginal>
            //
            ;



            set TotalNumberOfCores=0



            //
            // The wmic command generates one line per CPU socket, and each line is of the form
            // "NumberOfCores=18".
            //
            // As a result, the logic below generally sets NumberOfCores to the per-socket CPU count,
            // while setting TotalNumberOfCores to the total core count across sockets.
            //
            // Ref from chrisahnx74, with blank lines removed:
            //
            //    [[
            //      $ wmic cpu get NumberOfCores /value
            //      NumberOfCores=18
            //      NumberOfCores=18
            //    ]]
            //

            for /f "tokens=*" %%I in (
                'wmic cpu get NumberOfCores /value ^| find "=" 2^>NUL'
              )
                do (

                set %%I
                set /a TotalNumberOfCores=TotalNumberOfCores+NumberOfCores
            )



            //
            // Overwrite NumberOfCores to move it from a per-socket quantity to a machine-wide
            // quantity.
            //

            set NumberOfCores=!TotalNumberOfCores!


        ) // End of: if not defined NumberOfCores



        echo %__MsgPrefix%Number of processor cores %NumberOfCores%



        //
        // <InOriginal>
        // Start the build steps.
        // </InOriginal>
        //
        ;



        @if defined _echo @echo on



        call "%__RepoRootDir%\eng\native\version\copy_version_files.cmd"



        set __IntermediatesIncDir=%__IntermediatesDir%\src\inc



        set __IntermediatesEventingDir=%__ArtifactsIntermediatesDir%\Eventing\%__TargetArch%\%__BuildType%



        //
        // <InOriginal>
        // Find python and set it to the variable PYTHON
        // </InOriginal>
        //
        // Ref (after opening Visual Studio Installer, selecting "Modify" on the VS2022
        // installation, and then installing Python from the "Individual Components" list):
        //
        //    [[
        //      $ where py
        //      C:\Windows\py.exe
        //
        //      C:\tmp $ py -3 -c "import sys; sys.stdout.write(sys.executable)"
        //      C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python39_64\python.exe
        //    ]]
        //
        ;



        set _C=-c "import sys; sys.stdout.write(sys.executable)"



        (py -3 %_C% || py -2 %_C% || python3 %_C% || python2 %_C% || python %_C%) > "%TEMP%\pythonlocation.txt" 2> NUL



        set _C=



        set /p PYTHON=<"%TEMP%\pythonlocation.txt"



        if NOT DEFINED PYTHON (
            echo %__ErrMsgPrefix%%__MsgPrefix%Error: Could not find a Python installation.
            goto ExitWithError
        )



        set __CMakeTarget=



        for /f "delims=" %%a in ("-%__RequestedBuildComponents%-") do (



            set "string=%%a"



            if not "!string:-hosts-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! hosts
            )



            if not "!string:-jit-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! jit
            )



            if not "!string:-alljits-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! alljits
            )



            if not "!string:-runtime-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! runtime
            )



            if not "!string:-paltests-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! paltests_install
            )



            if not "!string:-iltools-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! iltools
            )



            if not "!string:-nativeaot-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! nativeaot
            )



            if not "!string:-spmi-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! spmi
            )



            if not "!string:-crosscomponents-=!"=="!string!" (
                set __CMakeTarget=!__CMakeTarget! crosscomponents
            )



            continue;


        ) // End of: for /f "delims=" %%a in ("-%__RequestedBuildComponents%-")



        //
        // If no specific components are being targeted (i.e., if this is the "all" case), then the
        // build implicitly targets the "install" target.
        //

        if "!__CMakeTarget!" == "" (
            set __CMakeTarget=install
        )



        //
        // <InOriginal>
        // Build Native assets including CLR runtime.
        // </InOriginal>
        //

        if %__BuildNative% EQU 1 (



            setlocal
            {


                echo %__MsgPrefix%Commencing build of native components for %__TargetOS%.%__TargetArch%.%__BuildType%



                //
                // <InOriginal>
                // Set the environment for the native build.
                // </InOriginal>
                //
                ;



                set __VCTargetArch=amd64



                if /i "%__HostArch%" == "x86" (
                    set __VCTargetArch=x86
                )



                if /i "%__HostArch%" == "arm" (
                    set __VCTargetArch=x86_arm
                )



                if /i "%__HostArch%" == "arm64" (
                    set __VCTargetArch=x86_arm64
                )



                echo %__MsgPrefix%Using environment: "%__VCToolsRoot%\vcvarsall.bat" !__VCTargetArch!



                call "%__VCToolsRoot%\vcvarsall.bat" !__VCTargetArch!



                @if defined _echo @echo on



                if defined __SkipConfigure (
                    goto :SkipConfigure
                )



                echo %__MsgPrefix%Regenerating the Visual Studio solution



                if %__Ninja% EQU 1 (
                    set __ExtraCmakeArgs="-DCMAKE_BUILD_TYPE=!__BuildType!"
                )



                set __ExtraCmakeArgs=
                    !__ExtraCmakeArgs!
                    "-DCLR_CMAKE_TARGET_ARCH=%__TargetArch%"
                    "-DCLR_CMAKE_TARGET_OS=%__TargetOS%"
                    "-DCLR_CMAKE_PGO_INSTRUMENT=%__PgoInstrument%"
                    "-DCLR_CMAKE_OPTDATA_PATH=%__PgoOptDataPath%"
                    "-DCLR_CMAKE_PGO_OPTIMIZE=%__PgoOptimize%"
                    %__CMakeArgs%



                echo Calling "%__RepoRootDir%\eng\native\gen-buildsys.cmd" "%__ProjectDir%" "%__IntermediatesDir%" %__VSVersion% %__HostArch% !__ExtraCmakeArgs!



                call "%__RepoRootDir%\eng\native\gen-buildsys.cmd"
                    "%__ProjectDir%"
                    "%__IntermediatesDir%"
                    %__VSVersion%
                    %__HostArch%
                    !__ExtraCmakeArgs!



                if not !errorlevel! == 0 (
                    echo %__ErrMsgPrefix%%__MsgPrefix%Error: failed to generate native component build project!
                    goto ExitWithError
                )



                @if defined _echo @echo on



            :SkipConfigure



                if not exist "%__IntermediatesDir%\CMakeCache.txt" (
                    echo %__ErrMsgPrefix%%__MsgPrefix%Error: unable to find generated native component build project!
                    goto ExitWithError
                )



                if defined __ConfigureOnly (
                    goto :SkipNativeBuild
                )



                set __BuildLogRootName=CoreCLR



                set "__BuildLog="%__LogsDir%\!__BuildLogRootName!_%__TargetOS%__%__TargetArch%__%__BuildType%__%__HostArch%.log""



                set "__BuildWrn="%__LogsDir%\!__BuildLogRootName!_%__TargetOS%__%__TargetArch%__%__BuildType%__%__HostArch%.wrn""



                set "__BuildErr="%__LogsDir%\!__BuildLogRootName!_%__TargetOS%__%__TargetArch%__%__BuildType%__%__HostArch%.err""



                set "__BinLog="%__LogsDir%\!__BuildLogRootName!_%__TargetOS%__%__TargetArch%__%__BuildType%__%__HostArch%.binlog""



                set "__MsbuildLog=/flp:Verbosity=normal;LogFile=!__BuildLog!"



                set "__MsbuildWrn=/flp1:WarningsOnly;LogFile=!__BuildWrn!"



                set "__MsbuildErr=/flp2:ErrorsOnly;LogFile=!__BuildErr!"



                set "__MsbuildBinLog=/bl:!__BinLog!"



                set "__Logging=!__MsbuildLog! !__MsbuildWrn! !__MsbuildErr! !__MsbuildBinLog! !__ConsoleLoggingParameters!"



                set __CmakeBuildToolArgs=



                if %__Ninja% EQU 1 (



                    set __CmakeBuildToolArgs=



                ) else ( // I.e., if !(%__Ninja% EQU 1)



                    //
                    // <InOriginal>
                    //
                    // We pass the /m flag directly to MSBuild so that we can get both MSBuild and CL
                    // parallelism, which is fastest for our builds.
                    //
                    // </InOriginal>
                    //

                    set __CmakeBuildToolArgs=/nologo /m !__Logging!


                ) // End of: else // I.e., if !(%__Ninja% EQU 1)



                echo running "%CMakePath%" --build %__IntermediatesDir% --target %__CMakeTarget% --config %__BuildType% -- !__CmakeBuildToolArgs!



                "%CMakePath%"
                    --build %__IntermediatesDir%
                    --target %__CMakeTarget%
                    --config %__BuildType%
                    -- !__CmakeBuildToolArgs!



                if not !errorlevel! == 0 (



                    set __exitCode=!errorlevel!



                    echo %__ErrMsgPrefix%%__MsgPrefix%Error: native component build failed. Refer to the build log files for details.

                    echo     !__BuildLog!

                    echo     !__BuildWrn!

                    echo     !__BuildErr!



                    goto ExitWithCode


                ) // End of: if not !errorlevel! == 0 (



                if %__EnforcePgo% EQU 1 (



                    set PgoCheckCmd="!PYTHON!" "!__ProjectDir!\scripts\pgocheck.py" "!__BinDir!\coreclr.dll" "!__BinDir!\clrjit.dll"



                    echo !PgoCheckCmd!



                    !PgoCheckCmd!



                    if not !errorlevel! == 0 (



                        set __exitCode=!errorlevel!



                        echo !__ErrMsgPrefix!!__MsgPrefix!Error: Error running pgocheck.py on coreclr and clrjit.



                        goto ExitWithCode


                    ) // End of: if not !errorlevel! == 0


                ) // End of: if %__EnforcePgo% EQU 1



            :SkipNativeBuild



            }
            endlocal


        ) // End of: if %__BuildNative% EQU 1



        //
        // <InOriginal>
        // All builds complete!
        // </InOriginal>
        //
        ;



        echo %__MsgPrefix%Build succeeded.  Finished at %TIME%



        echo %__MsgPrefix%Product binaries are available at !__BinDir!



        exit /b 0




    //
    // <InOriginal>
    //
    // These two routines are intended for the exit code to propagate to the parent process,
    // e.g., MSBuild or Powershell.
    //
    // If we directly "exit /b 1" from within a if statement in any of the routines, the exit
    // code is not propagated.
    //
    // </InOriginal>
    //
    ;



    :ExitWithError

        exit /b 1



    :ExitWithCode

        exit /b !__exitCode!



    :Usage



        echo.
        echo Build the CoreCLR repo.
        echo.
        echo Usage:
        echo     build-runtime.cmd [option1] [option2]
        echo or:
        echo     build-runtime.cmd all [option1] [option2]
        echo.
        echo All arguments are optional. The options are:
        echo.
        echo.-? -h -help --help: view this message.
        echo -all: Builds all configurations and platforms.
        echo Build architecture: one of -x64, -x86, -arm, -arm64 ^(default: -x64^).
        echo Build type: one of -Debug, -Checked, -Release ^(default: -Debug^).
        echo -component ^<name^> : specify this option one or more times to limit components built to those specified.
        echo                     Allowed ^<name^>: hosts jit alljits runtime paltests iltools nativeaot spmi
        echo -enforcepgo: verify after the build that PGO was used for key DLLs, and fail the build if not
        echo -pgoinstrument: generate instrumented code for profile guided optimization enabled binaries.
        echo -cmakeargs: user-settable additional arguments passed to CMake.
        echo -configureonly: skip all builds; only run CMake ^(default: CMake and builds are run^)
        echo -skipconfigure: skip CMake ^(default: CMake is run^)
        echo -skipnative: skip building native components ^(default: native components are built^).
        echo.
        echo Examples:
        echo     build-runtime
        echo        -- builds x64 debug, all components
        echo     build-runtime -component jit
        echo        -- builds x64 debug, just the JIT
        echo     build-runtime -component jit -component runtime
        echo        -- builds x64 debug, just the JIT and runtime
        echo.
        echo If "all" is specified, then all build architectures and types are built. If, in addition,
        echo one or more build architectures or types is specified, then only those build architectures
        echo and types are built.
        echo.
        echo For example:
        echo     build-runtime -all
        echo        -- builds all architectures, and all build types per architecture
        echo     build-runtime -all -x86
        echo        -- builds all build types for x86
        echo     build-runtime -all -x64 -x86 -Checked -Release
        echo        -- builds x64 and x86 architectures, Checked and Release build types for each



        exit /b 1

}







{l:\Git\github\dotnet\runtime\eng\native\init-vs-env.cmd}


    //
    // This script is reached, e.g., along the following stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\native\init-vs-env.cmd}
    //      {l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}
    //      ...
    //

{


    @if not defined _echo @echo off



    //
    // <InOriginal>
    //
    // Initializes Visual Studio developer environment.
    //
    // If a build architecture is passed as an argument, it also initializes VC++ build
    // environment and CMakePath.
    //
    // </InOriginal>
    //
    ;



    set "__VCBuildArch="



    if /i "%~1" == "x86"    ( set __VCBuildArch=x86 )

    if /i "%~1" == "x64"    ( set __VCBuildArch=x86_amd64 )

    if /i "%~1" == "arm"    ( set __VCBuildArch=x86_arm )

    if /i "%~1" == "arm64"  ( set __VCBuildArch=x86_arm64 )

    if /i "%~1" == "wasm"   ( set __VCBuildArch=x86_amd64 )



    //
    // <InOriginal>
    //
    // Default to highest Visual Studio version available that has Visual C++ tools.
    //
    // For VS2017 and later, multiple instances can be installed on the same box SxS and
    // VS1*0COMNTOOLS is no longer set as a global environment variable and is instead only set
    // if the user has launched the Visual Studio Developer Command Prompt.
    //
    // Following this logic, we will default to the Visual Studio toolset associated with the
    // active Developer Command Prompt.
    //
    // Otherwise, we will query VSWhere to locate the later version of Visual Studio available
    // on the machine.
    //
    // Finally, we will fail the script if no supported instance can be found.
    //
    // </InOriginal>
    //
    ;



    if defined VisualStudioVersion (
        goto :VSDetected
    )



    set "__VSWhere=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"



    set "__VSCOMNTOOLS="



    if exist "%__VSWhere%" (



        for /f "tokens=*" %%p in (
            '
                "%__VSWhere%"
                    -latest
                    -prerelease
                    -products *
                    -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64
                    -property installationPath
            '
          )
            do (

            set __VSCOMNTOOLS=%%p\Common7\Tools
        )


    ) // End of: if exist "%__VSWhere%"



    if not exist "%__VSCOMNTOOLS%" (
        goto :VSMissing
    )



    //
    // <InOriginal>
    // Make sure the current directory stays intact.
    // </InOriginal>
    //

    set "VSCMD_START_DIR=%CD%"



    call "%__VSCOMNTOOLS%\VsDevCmd.bat" -no_logo



    //
    // <InOriginal>
    // Clean up helper variables.
    // </InOriginal>
    //
    ;



    set "__VSWhere="



    set "__VSCOMNTOOLS="



    set "VSCMD_START_DIR="



:VSDetected



    if "%VisualStudioVersion%"=="17.0"
    (


        set __VSVersion=vs2022



        set __PlatformToolset=v143



        goto :SetVCEnvironment


    ) // End of: if "%VisualStudioVersion%"=="17.0"



    goto :VSMissing



:VSMissing



    echo %__MsgPrefix%Error: Visual Studio 2022 with C++ tools required. ^
        Please see https://github.com/dotnet/runtime/blob/main/docs/workflow/requirements/windows-requirements.md for build requirements.



    exit /b 1



:SetVCEnvironment



    if "%__VCBuildArch%"=="" (
        exit /b 0
    )



    //
    // <InOriginal>
    // Set the environment for the native build.
    // </InOriginal>
    //
    ;



    call "%VCINSTALLDIR%Auxiliary\Build\vcvarsall.bat" %__VCBuildArch%



    if not "%ErrorLevel%"=="0" (
        exit /b 1
    )



    set "__VCBuildArch="



    //
    // <InOriginal>
    //
    // Set CMakePath by evaluating the output from set-cmake-path.ps1.
    //
    // In case of a failure the output is "exit /b 1".
    //
    // </InOriginal>
    //

    for /f "delims=" %%a in (
        '
            powershell
                -NoProfile
                -ExecutionPolicy ByPass
                -File "%~dp0set-cmake-path.ps1"
        '
      )
        do (

        %%a
    )


}





{l:\Git\github\dotnet\runtime\eng\native\set-cmake-path.ps1}


    //
    // This script is reached, e.g., along the following stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\native\set-cmake-path.ps1}
    //      {l:\Git\github\dotnet\runtime\eng\native\init-vs-env.cmd}
    //      {l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}
    //      ...
    //

{


    //
    // <InOriginal>
    //
    // This script locates the CMake executable for the build system and outputs either the
    //
    //      "set CMakePath=..."
    //
    // command (if CMake is found) or the
    //
    //      "exit /b 1"
    //
    // command (if not found) for evaluating from batch files.
    //
    // </InOriginal>
    //
    ;



    Set-StrictMode -Version 3



    function LocateCMake
    {


        //
        // <InOriginal>
        // Find the first cmake.exe on the PATH.
        // </InOriginal>
        //
        ;



        $cmakeApp = (
            Get-Command
                cmake.exe
                -ErrorAction SilentlyContinue
        )



        if ($cmakeApp -ne $null)
        {
            return $cmakeApp.Path
        }



        //
        // <InOriginal>
        // Find cmake.exe using the registry.
        // </InOriginal>
        //
        ;



        $cmakeRegKey =
            Get-ItemProperty
                HKLM:\SOFTWARE\Kitware\CMake
                -Name InstallDir
                -ErrorAction SilentlyContinue



        if ($cmakeRegKey -eq $null)
        {


            $cmakeRegKey =
                Get-ItemProperty
                    HKLM:\SOFTWARE\Wow6432Node\Kitware\CMake
                    -Name InstallDir
                    -ErrorAction SilentlyContinue


        } // End of: if ($cmakeRegKey -eq $null)



        if ($cmakeRegKey -ne $null)
        {


            $cmakePath = (
                $cmakeRegKey.InstallDir + "bin\cmake.exe"
            );



            if (Test-Path $cmakePath -PathType Leaf)
            {
                return $cmakePath
            }


        } // End of: if ($cmakeRegKey -ne $null)



        return $null


    } // End of: function LocateCMake



    try
    {


        $cmakePath = LocateCMake



        if ($cmakePath -eq $null)
        {


            throw
                "CMake is a pre-requisite to build this repository but it was not found on the PATH or in the registry. "
                "Please install CMake from https://cmake.org/download/."


        } // End of: if ($cmakePath -eq $null)



        $version = [Version]$(
                & $cmakePath --version
            |
                Select-String -Pattern '\d+\.\d+\.\d+'
            |
                %{$_.Matches.Value}
        )



        if ($version -lt [Version]"3.16.4")
        {


            throw
                "CMake 3.16.4 or newer is required for building this repository. The newest version of CMake installed is $version. "
                "Please install CMake 3.16.4 or newer from https://cmake.org/download/."


        } // End of: if ($version -lt [Version]"3.16.4")



        [System.Console]::WriteLine(
            "set CMakePath=" + $cmakePath
        )


    }
    catch
    {


        [System.Console]::Error.WriteLine(
          $_
            .Exception
            .Message
        )



        [System.Console]::WriteLine(
            "exit /b 1"
        )


    } // End of: catch


}







{l:\Git\github\dotnet\runtime\eng\native\gen-buildsys.cmd}


    //
    // This script is reached, e.g., along the following stack:
    //
    //      {l:\Git\github\dotnet\runtime\eng\native\gen-buildsys.cmd}
    //      {l:\Git\github\dotnet\runtime\eng\native\init-vs-env.cmd}
    //      {l:\Git\github\dotnet\runtime\src\coreclr\build-runtime.cmd}
    //      ...
    //

{


    @if not defined _echo @echo off



    //
    // <InOriginal>
    // This file invokes cmake and generates the build system for windows.
    // </InOriginal>
    //
    ;



    setlocal



    set argC=0

    for %%x in (%*) do (
        Set /A argC+=1
    )



    if %argC% lss 4 (
        GOTO :USAGE
    )



    if %1=="/?" (
        GOTO :USAGE
    )



    setlocal enabledelayedexpansion



    //
    // <InOriginal>
    // Remove quotes and remove trailing slash.
    // </InOriginal>
    //

    set basePath=%~dp0

    set "basePath=%basePath:"=%"

    if %basePath:~-1%==\ (
        set "basePath=%basePath:~0,-1%"
    )



    set __repoRoot=%~dp0..\..\




    set __SourceDir=%1



    set __IntermediatesDir=%2



    set __VSVersion=%3



    set __Arch=%4



    set __CmakeGenerator=Visual Studio



    set __UseEmcmake=0



    if /i "%__Ninja%" == "1" (



        set __CmakeGenerator=Ninja



    ) else ( // I.e., if /i NOT "%__Ninja%" == "1"



        if /i "%__Arch%" == "wasm" (



            set __CmakeGenerator=NMake Makefiles



        ) else ( // I.e., if /i NOT "%__Arch%" == "wasm"



            if /i "%__VSVersion%" == "vs2022" (
                set __CmakeGenerator=%__CmakeGenerator% 17 2022
            )



            if /i "%__Arch%" == "x64" (
                set __ExtraCmakeParams=%__ExtraCmakeParams% -A x64
            )



            if /i "%__Arch%" == "arm" (
                set __ExtraCmakeParams=%__ExtraCmakeParams% -A ARM
            )



            if /i "%__Arch%" == "arm64" (
                set __ExtraCmakeParams=%__ExtraCmakeParams% -A ARM64
            )



            if /i "%__Arch%" == "x86" (
                set __ExtraCmakeParams=%__ExtraCmakeParams% -A Win32
            )


        ) // End of: else ( // I.e., if /i NOT "%__Arch%" == "wasm"


    ) // End of: else ( // I.e., if /i NOT "%__Ninja%" == "1"



    if /i NOT "%__Arch%" == "wasm" (



        set __ExtraCmakeParams=%__ExtraCmakeParams% "-DCMAKE_SYSTEM_VERSION=10.0"



    ) else ( // I.e., if /i "%__Arch%" == "wasm"



        if "%EMSDK_PATH%" == "" (



            if not exist "%__repoRoot%src\mono\wasm\emsdk" (
                echo Error: Should set EMSDK_PATH environment variable pointing to emsdk root.
                exit /B 1
            )



            set EMSDK_PATH=%__repoRoot%src\mono\wasm\emsdk



            set EMSDK_PATH=!EMSDK_PATH:\=/!


        ) // End of: if "%EMSDK_PATH%" == ""



        set __ExtraCmakeParams=%__ExtraCmakeParams% "-DCMAKE_TOOLCHAIN_FILE=!EMSDK_PATH!/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake"



        set __UseEmcmake=1


    ) // End of: else ( // I.e., if /i "%__Arch%" == "wasm"



    :loop



        if [%5] == [] (
            goto end_loop
        )



        set __ExtraCmakeParams=%__ExtraCmakeParams% %5

        shift

        goto loop



    :end_loop



    set __ExtraCmakeParams=
        "-DCMAKE_INSTALL_PREFIX=%__CMakeBinDir%"
        "-DCLR_CMAKE_HOST_ARCH=%__Arch%"
        %__ExtraCmakeParams%



    set __CmdLineOptionsUpToDateFile=%__IntermediatesDir%\cmake_cmd_line.txt



    set __CMakeCmdLineCache=



    if not "%__ConfigureOnly%" == "1" (



        //
        // <InOriginal>
        //
        // MSBuild can't reload from a CMake reconfigure during build correctly, so only do this
        // command-line up to date check for non-VS generators.
        //
        // </InOriginal>
        //

        if "%__CmakeGenerator:Visual Studio=%" == "%__CmakeGenerator%" (



            if not exist "%__CmdLineOptionsUpToDateFile%" (



                echo %__ExtraCmakeParams% > %__CmdLineOptionsUpToDateFile%



            ) else ( // I.e., if exist "%__CmdLineOptionsUpToDateFile%"



                set /p __CMakeCmdLineCache=<"%__CmdLineOptionsUpToDateFile%"



                //
                // <InOriginal>
                // Strip the extra space from the end of the cached command line.
                // </InOriginal>
                //

                if "!__ExtraCmakeParams!" == "!__CMakeCmdLineCache:~0,-1!" (
                    echo The CMake command line is the same as the last run. Skipping running CMake.
                    exit /B 0
                )



                echo The CMake command line differs from the last run. Running CMake again.



                echo %__ExtraCmakeParams% > %__CmdLineOptionsUpToDateFile%


            ) // End of: else ( // I.e., if exist "%__CmdLineOptionsUpToDateFile%"


        ) // End of: if "%__CmakeGenerator:Visual Studio=%" == "%__CmakeGenerator%"


    ) // End of: if not "%__ConfigureOnly%" == "1"



    if /i NOT "%__UseEmcmake%" == "1" (



        "%CMakePath%"
            %__ExtraCmakeParams%
            --no-warn-unused-cli
            -G "%__CmakeGenerator%"
            -B %__IntermediatesDir%
            -S %__SourceDir%



    ) else ( // I.e., if /i "%__UseEmcmake%" == "1"



        call "!EMSDK_PATH!/emsdk_env.bat" > nul 2>&1



        emcmake
            "%CMakePath%"
            %__ExtraCmakeParams%
            --no-warn-unused-cli
            -G "%__CmakeGenerator%"
            -B %__IntermediatesDir%
            -S %__SourceDir%


    ) // End of: else ( // I.e., if /i "%__UseEmcmake%" == "1"



    endlocal



    exit /B %errorlevel%



    :USAGE



        echo "Usage..."

        echo "gen-buildsys.cmd <path to top level CMakeLists.txt> <path to location for intermediate files> <VSVersion> <arch>"

        echo "Specify the path to the top level CMake file - <ProjectK>/src/NDP"

        echo "Specify the VSVersion to be used - VS2017 or VS2019"



        EXIT /B 1


}




